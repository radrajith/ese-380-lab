
AVRASM ver. 2.1.52  C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\final finished code\final finished code\final finished code.asm Thu Nov 27 18:36:06 2014

C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\final finished code\final finished code\final finished code.asm(38): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.39.1005\avrassembler\Include\m16def.inc'
C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\final finished code\final finished code\final finished code.asm(411): Including file 'C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\final finished code\final finished code\audio_playback_WTV20SD_beta.inc'
C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\final finished code\final finished code\final finished code.asm(847): Including file 'C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\final finished code\final finished code\lcd_dog_asm_driver_m16A.inc'
                 
                 
                  *
                  * Lab 11 - final code
                  *
                  ; This is the final program. Menu screen will be the default screen. The menu screen 
                  ; will let you choose between RUN, HOLD, ALARM, CAPTURE, FREQUENCY. 
                  ; when its in run mode the code will read the input analog voltage. when its in hold 
                  ; mode it will retain the value, and doesnt read again until the pbsw is pressed again.
                  ; When its in alarm mode, there will be option to set an alarm voltage between 4 option
                  ; when the voltage is set, the circuit will beep when the read voltage is above it. 
                  ; when in capture mode, the new voltage will be captured and remain in the screen 
                  ; until next voltage is read. under the capture mode, it will speak out the voltage 
                  ; that is read. the down button can be used to toggle between audio on and off. when 
                  ; audio is off the captured voltage will not be read. Freq mode is similar to the one
                  ; done in lab 8, the freq generated in inputted in PA5. The backlight will turn off 
                  ; in 5 seconds when not used. If any button is pressed, or new voltage is read. 
                  ; 
                  ;Hardware used - max144 voltage reader, level shifter, audio output module
                  ; registers used by code written by me
                  ; r1 - r4 to unpack the bits of the read ascii voltage or frequency
                  ; r5 - r7, r10 - to unpack the read ascii voltage or frequency
                  ; r8 and r9 to copy the 12 bit value obtained after convertion
                  ; r16 for general purpose like initilization etc
                  ; r17 as a space counter used in the display subroutine
                  ; r23 use as toggle between audio on and off
                  ; r28 initialized to 6. to keep r17 in check 
                  ; r21 - used to find which menu has been selected
                  ; r18 and r19 - copies r8 and r9 values
                 
                  ; r27 as a toggle register. changes between 1 or 0 with press of center button 
                  ;r8 and r9 will be used to store the adc conversion values
                  *  Created: 10/29/2014 2:17:13 PM
                  *   Author: radra_000
                  
                  */
                  
                 .LIST 
                 
                 
                  ;********************************************************************
                 	 .cseg 
                 	 .org 0								;reset/restart code entry point <<<<<<<< 
000000 940c 0010 	 jmp reset	
                 	 
                 	 
                 	 
                 	 //when the counter is equal to 1s, the interrupt will be called
                 	 //0x0E is the adress for timer compare match B. 
                 	 //when the interrupt is called, it will jump to isr_tc0_display
                 	.org 0x002							;when external interrupt is pressed
000002 940c 00c5 	jmp menu							;its located on pd2
                 	.org 0x00C							;timer interrupt A
00000c 940c 00bc 	jmp off								;to turn off backlight display
                 
                 	.org 0x00E							; timer interrupt B
00000e 940c 00b2 	jmp isr_tc0_display					; display the frequency count
                 
                 
                 reset:
000010 e50f      	ldi r16, low(ramend)
000011 bf0d      	out spl, r16
000012 e004      	ldi r16, high(ramend)
000013 bf0e      	out sph, r16						;initialize stack pointer
                 //button interrupt
000014 e003      	LDI r16,$03
000015 bf05      	out mcucr, r16
000016 e400      	ldi r16, 1 << INT0
000017 bf0b      	out gicr, r16						;initialize button interrupt
                 //input/output	
000018 e000      	ldi r16, $00
000019 bb01      	out ddrd, r16						;set up the port b as inputs to read the pbsw values
00001a ef0f      	ldi r16, 0xff						; set portB = output.
00001b bb02      	out portd, r16
00001c eb0f      	ldi r16, 0b10111111	
00001d bb07          out ddrb, r16						; for lcd display
00001e 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
00001f 9ac0      	sbi portb, 0
000020 e001      	ldi r16, 1							; set DDRC for all in but PC0
000021 bb04      	out ddrc, r16
000022 9aa8      	sbi portc, 0						; turn off sounder
000023 e207      	ldi r16,0b00100111					; set up port a to 
000024 bb0a      	out ddra, r16						;read the frequency input on pa7 and output pulse on pa6
000025 9ad8      	sbi porta, 0						;
000026 9ad9      	sbi porta, 1						
000027 9ada      	sbi porta, 2						;setting up the audio voltage reading inputs
000028 d335      	rcall init_lcd_dog					;initialize lcd dog
                 	//cbi porta, 5
                 	//rcall enable_backlight
000029 94e8      	clt									;clear t flag
00002a e000      	ldi r16, 0
00002b e050      	ldi r21, 0
00002c e180      	ldi r24, $10
00002d d14d      	rcall start_tc1
00002e e003      	ldi r16, 0<<CS12|1<<CS11|1<<CS10	; load 64 PRESCaLE TCCR0 value. 
00002f bd0e      	out TCCR1B, r16						; and start timer
000030 9478      	sei									;enable global interrupts
                 ;***************************************
                 ; check which menu is selected. r21 is  either incremented or decremented
                 ; with press of right or left pbsw. when the go button is pressed the 
                 ; corresponding menu is selected
                 ;****************************************
                 main:
000031 3050      	cpi r21, 0
000032 f041      	breq run							
000033 3051      	cpi r21, 1
000034 f0a9      	breq hold
000035 3052      	cpi r21, 2
000036 f121      	breq capture1
000037 3053      	cpi r21, 3
000038 f119      	breq alarm
000039 3054      	cpi r21, 4
00003a f0f9      	breq freq_meter1
                 ;*********************run menu***********************
                 ; when in run mode the voltage is continuously read and 
                 ; displayed. 
                 ;****************************************************
                 run:
00003b 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
00003c 9ac0      	sbi portb, 0
00003d d146      	rcall spi_setup					;sets up and gets the voltage from the max144
00003e d3a7      	rcall unpack					;conver the obtained values to numbers
00003f 2d2a      	mov r18, r10					; get the 1 and 3 digit of the voltage value
000040 2d36      	mov r19, r6						; copy it to r18 and r19
000041 9522      	swap r18						; shift the 1 digit to upper dibble
000042 2723      	eor r18, r19					; exor it to obtain both digit in one register
000043 e439      	ldi r19, $49					; 
000044 1723      	cp r18,r19						; check if its more than 49, if its greater it 
000045 f410      	brsh overflow_dis				; means the read voltage is more than 4090
000046 d219      	rcall run_display				;display measured value. 
000047 cfe9      	rjmp main						;return to main to see if a different option is 
                 									;selected
                 overflow_dis:
000048 d271      	rcall overflow					;displays overflow on the display and goes back 
000049 cfe7      	rjmp main						; to main 
                 ;********************hold mode***************************
                 ;with the press of the center button it will toggle the tflag
                 ;when t flag is set its in hold mode, if not it will just display
                 ;voltage like in run mode
                 ;********************************************************
                 hold:
00004a e000      	ldi r16, 0
00004b bf09      	out TIMSK, r16						;set up the timer interrupt
00004c f3ee      	brts hold							;if t flag is set it means its in hold mode 
00004d 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
00004e 9ac0      	sbi portb, 0
00004f d134      	rcall spi_setup					;sets up and gets the voltage from the max144
000050 d395      	rcall unpack					;conver the obtained values to numbers
000051 2d2a      	mov r18, r10
000052 2d36      	mov r19, r6
000053 9522      	swap r18
000054 2723      	eor r18, r19
000055 e439      	ldi r19, $49
000056 1723      	cp r18,r19
000057 f780      	brsh overflow_dis					;check if it overflows
000058 d225      	rcall hold_display					;display measured value. 
000059 cfd7      	rjmp main
                 freq_meter1:							;added because the rcall cannot reach there
00005a c038      	rjmp freq_meter				
                 capture1:
00005b c01a      	rjmp capture
                 ;******************alarm mode*************************************
                 ;this mode will sound the beeper if the measured voltage is above
                 ; the selected voltage range. 
                 ;*****************************************************************
                 alarm:
00005c 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
00005d 9ac0      	sbi portb, 0
00005e d125      	rcall spi_setup					;sets up and gets the voltage from the max144
00005f d386      	rcall unpack					;conver the obtained values to numbers
000060 2d2a      	mov r18, r10
000061 2d36      	mov r19, r6
000062 9522      	swap r18
000063 2723      	eor r18, r19
000064 e439      	ldi r19, $49
000065 1723      	cp r18,r19
000066 f708      	brsh overflow_dis					;check if the selected voltage overflows
000067 d234      	rcall alarm_display					;display measured value. 
000068 2722      	clr r18								; do the similar procedure as the overflow
000069 2d2a      	mov r18, r10						;check. to if the read voltage is above
00006a 2d37      	mov r19, r7							; the selected voltage
00006b 9522      	swap r18							; load r19 with 30 and add it with r23
00006c 2723      	eor r18, r19						; r23 contains the value of the selected 
00006d e330      	ldi r19, $30						;voltage limit(either 5/6/7/8)	
00006e 0f37      	add r19, r23					
00006f 1723      	cp r18,r19							;compare if >35/36/37/38					
000070 f408      	brsh alarmed						;if higher than that go to alarm
000071 cfbf      	rjmp main							;if not just read the next voltage
                 alarmed:
000072 98a8      	cbi portc, 0						;start the beeper
000073 d3a6      	rcall delay							;wait 
000074 9aa8      	sbi portc, 0						;stop the beeper
000075 cfbb      	rjmp main							;read the next voltage
                 ;************************alarm mode*********************************
                 ; read the voltage value and hold it. until the next voltage is read
                 ; so it will only read a new value after the wire is removed, meaning
                 ; the voltage has to be zero in order to read the next value
                 ;******************************************************************
                 
                 capture:
000076 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
000077 9ac0      	sbi portb, 0
000078 d10b      	rcall spi_setup					;sets up and gets the voltage from the max144
000079 e000      	ldi r16, $00
00007a 1509      	cp r16, r9						; compare if the 4msb of the voltage is 0
00007b f419      	brne next						; if not then dont read next voltage value
00007c ef0a      	ldi r16, 250					; compare if the 8 lsb is <250mV
00007d 1508      	cp r16,r8						; if its less than 250 
00007e f410      	brsh clear						; clear the t flag to read the next voltage value
                 next:
00007f f41e      	brtc run_once					; if tflag is cleared then read the next voltage
000080 cfb0      	rjmp main
                 clear:
000081 94e8      	clt								; clear t flag to read the next voltag
000082 cfae      	rjmp main
                 run_once:
000083 d362      	rcall unpack					;conver the obtained values to numbers
000084 2d2a      	mov r18, r10
000085 2d36      	mov r19, r6
000086 9522      	swap r18
000087 2723      	eor r18, r19
000088 e439      	ldi r19, $49
000089 1723      	cp r18,r19
00008a f530      	brsh overflow_dis1				;check for overflow
00008b d19c      	rcall capture_display			;display measured value. 
00008c ff70      	sbrs r23, 0						; if r23 is 0 it means audio should
00008d d0d8      	rcall audio						;be off
00008e 98a8      	cbi portc, 0					;beep 
00008f d38a      	rcall delay						
000090 9aa8      	sbi portc, 0
000091 9468      	set								; set t flag to indicate to not read new value
000092 cf9e      	rjmp main						;calculation in the second run 
                 ;*********************frequency mode*********************************
                 ; this mode is similar to the freuqency meter done in lab 8
                 ; it will count the positive edges applied on pa7 for 1/2 second 
                 ; and display it on the lcd
                 ;********************************************************************
                 freq_meter:
000093 d246      	rcall freq_display					;after its unpacked, display 
000094 2488      	clr r8
000095 2499      	clr r9
000096 d0e4      	rcall start_tc1
000097 e003      	ldi r16, 0<<CS12|1<<CS11|1<<CS10	; load 64 PRESCaLE TCCR0 value. 
000098 bd0e      	out TCCR1B, r16						; and start timer
000099 d007      	rcall frequency_meter_3				; load the timer and count the frequency
00009a 94e8      	clt									;clear the t flag
00009b 1889      	sub r8, r9
00009c 2d28      	mov r18, r8
00009d 2d39      	mov r19, r9
00009e d347      	rcall unpack						;when timer is done, unpack the edge counts
00009f d23a      	rcall freq_display					;after its unpacked, display 
0000a0 cf90      	rjmp main							
                 
                 frequency_meter_3:
0000a1 e000      	ldi r16, $00
0000a2 2e80      	mov r8, r16
0000a3 2e90      	mov r9, r16
0000a4 b399      	in r25, pinA				;and positive edge counter
0000a5 7890      	andi r25,$80
                 	check_edge:		
0000a6 f04e      		brts finish2
0000a7 b309      		in r16, pina			;take in the current wave signal logic 
0000a8 7800      		andi r16,$80
0000a9 1709      		cp r16,r25			;and compare to previous logic recorded, 
0000aa f3d9      		breq check_edge			;if it is the same then skip to tweak delay		
0000ab 2f90      		mov r25, r16
0000ac 9483      		inc r8				;and then increment the counter
0000ad f7c1      		brne check_edge			;if it didnt over count then go to tweak delay
0000ae 9493      		inc r9				;if so then increment the second register
0000af f7b6      		brtc check_edge
                 	finish2:
                 		//ldi r16, 0<<OCIE1B
                 		//out TIMSK, r16						;set up the timer interrupt
0000b0 9508      		ret
                 
                 overflow_dis1:
0000b1 cf96      	rjmp overflow_dis
                 ;-----------------------------
                 ;when the interrupt is called it will jump to this subroutine
                 ;set the T flag, resets the timer, update the display 
                 
                 
                 isr_tc0_display:
                 ; when 1/2 secon dtim er is over this will be called, 
                 ; this subroutine is dual purpose, Timer A is used to control backlight
                 ; timer b is used to control the frequency. after .5 second is over
                 ; the t flag is set.
0000b2 930f      		push r16
0000b3 9583      		inc r24
0000b4 318a      		cpi r24, $1a
0000b5 f031      		breq off							; 
0000b6 9468      		set
0000b7 e000      		ldi r16, $00
0000b8 bd0d      		out TCNT1H, r16						; 
0000b9 bd0c      		out TCNT1L, r16						;reset the timer counter
0000ba 910f      		pop r16
0000bb 9518      		reti
                 off:
0000bc e180      		ldi r24, $10
0000bd 9add      		sbi porta, 5
0000be e000      		ldi r16, $00
0000bf bd0d      		out TCNT1H, r16						; 
0000c0 bd0c      		out TCNT1L, r16						;reset the timer counter
0000c1 910f      		pop r16
0000c2 e003      		ldi r16, 0<<CS12|1<<CS11|1<<CS10	; load 64 PRESCaLE TCCR0 value. 
0000c3 bd0e      		out TCCR1B, r16						; and start timer
0000c4 9518      		reti
                 
                 
                 ;************************menu button interrupt****************
                 ;when any pushbutton is pressed,this intterupt will be activated
                 ;*************************************************************
                 menu: 
0000c5 930f      	push r16
0000c6 98dd      	cbi porta, 5							;turn backlight on			
0000c7 9b83      	sbis pind, 3							;check if interrupt is pressed
0000c8 9add      	sbi porta, 5							;turn off te light
0000c9 3052      	cpi r21, 2								;check if the hold button is 
0000ca f419      	brne check_hold							;pressed(go button) in hold mode
0000cb 9b84      	sbis pind, 4							; check if down button is pressed
0000cc c01f      	rjmp audio_offon						;if pressed turn audio on/off
0000cd c004      	rjmp menu_loop
                 check_hold:
0000ce 3051      	cpi r21, 1								;check if we are in hold mode
0000cf f411      	brne menu_loop							;if not go to main loop
0000d0 9b87      	sbis pind, 7							;if yes is the go button pressed
0000d1 c01d      	rjmp switch								;if pressed then go to switch
                 menu_loop:	
0000d2 b300      	in r16, pind							;store the button presses
0000d3 9b85      	sbis pind, 5							;see if right buton is pressed
0000d4 9553      	inc r21									; increment r21
0000d5 9b86      	sbis pind, 6							;if left button is pressed 
0000d6 955a      	dec r21									;decrement r21
0000d7 ff07      	sbrs r16, 7								;if go button is pressed 
0000d8 c00d      	rjmp menu_check							;go to menu check 
                 wait_1:
0000d9 9b85      	sbis pind,5								;wait until right button is released
0000da cffe      	rjmp wait_1								
0000db 9b86      	sbis pind,6								;wait until left button is released
0000dc cffc      	rjmp wait_1
0000dd 3f5f      	cpi r21,$ff								;if its continuously pressed see if 
0000de f409      	brne check								;r21 is 255, if not go to check,if it
0000df e054      	ldi r21, 4								; is load r21 with 4 for hte freq mode
                 check:
0000e0 3055      	cpi r21,5								;
0000e1 f409      	brne good								; if r21 is 5 then reset back to 0
0000e2 e050      	ldi r21,0
                 good:
0000e3 94e8      	clt										;clear t flag
0000e4 d0b9      	rcall main_menu							;go to main menu
0000e5 cfec      	rjmp menu_loop							; chekc which button is pressed
                 menu_check:
0000e6 3053      	cpi r21,3								;if r21 is 3, ask for the check voltage
0000e7 f061      	breq alarm_set							;display 4 differnt volt to choose from 
                 menu_exit:
0000e8 e400      	ldi r16, 1 << INTF0						;when selection is done reset the interrupt
0000e9 bf0a      	out gifr, r16							;
0000ea 910f      	pop r16
0000eb 9518      	reti									;return from interrupt
                 audio_offon:
0000ec 9570      	com r23									;if r23 is 1 then audio is on and diplays it 
0000ed d13a      	rcall capture_display					; on the capture mode
0000ee cff9      	rjmp menu_exit 
                 
                 switch:
0000ef f016      	brts clear1								; if t flag is set, clear it 
0000f0 9468      	set										;if not set it 
0000f1 cff6      	rjmp menu_exit							;return back
                 clear1:
0000f2 94e8      	clt										;clear t falg
0000f3 cff4      	rjmp menu_exit							;return back
                 
                 alarm_set:
0000f4 d10d      	rcall alarm_select						;alarm selection menu
                 wait_press:
0000f5 9b83      	sbis pind, 3							
0000f6 c007      	rjmp done_select
0000f7 9b84      	sbis pind, 4
0000f8 c005      	rjmp done_select
0000f9 9b85      	sbis pind, 5
0000fa c003      	rjmp done_select
0000fb 9b86      	sbis pind, 6
0000fc c001      	rjmp done_select
0000fd cff7      	rjmp wait_press				;check which voltage is pressed
                 done_select:
0000fe d31b      	rcall delay
0000ff 9b83      	sbis pind, 3
000100 e075      	ldi r23, 5
000101 9b84      	sbis pind, 4
000102 e078      	ldi r23, 8
000103 9b85      	sbis pind, 5
000104 e076      	ldi r23, 6
000105 9b86      	sbis pind, 6
000106 e077      	ldi r23, 7				;debouncing the buttons
                 wait_for_1:
000107 d312      	rcall delay
000108 9b83      	sbis pind, 3
000109 cffd      	rjmp wait_for_1
00010a 9b84      	sbis pind, 4
00010b cffb      	rjmp wait_for_1
00010c 9b85      	sbis pind, 5
00010d cff9      	rjmp wait_for_1
00010e 9b86      	sbis pind, 6
00010f cff7      	rjmp wait_for_1
000110 94e8      	clt
000111 cfd6      	rjmp menu_exit
                 
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "audio_playback_WTV20SD_beta.inc" 
                 
                 ;;
                 ;;  -----------
                 ;;  modified mm/dd/yy  <initials>
                 ;;      <modification description text>
                 ;;  -----------
                 ;;  original release: 11/06/2014  FST  {BETA Version}
                 ;;      basic set of routines, including send_audio_r17r16 audio driver.
                 ;;--------------------------------------------------------------------------
                 
                 ;************************************************************************ 
                 ;  FILE NAME: audio_playback_WTV20SD_beta.inc    (Version 1b)
                 ;
                 ;  (ATmega16/ATmega16A  Initial Beta Version                                   
                 ;   
                 ;  This AVR-asm include module provides the asm-drivers to send
                 ;  audio playback message requests to the WTV20SD Audio Playback Module
                 ;
                 ;  This code is designed to be executed on an AVR ATMega micro-computer.
                 ;  
                 ;
                 ;************************************************************************
                 ;  This module contains all of the following procedures:
                 ;  ----------------------------------------------------
                 ;    1. Fixed DELAYS:
                 ;          audelay_30uS 
                 ;          audelay_300uS 
                 ;          audelay_1mS
                 ;          audelay_2mS
                 ;          audelay_40mS
                 ;    
                 ;    2. Audio request subroutine:
                 ;          send_audio_r17r16
                 ;
                 ;
                 
                 ;======== audmo DELAY ROUTINES =======================================	
                 
                 
                 
                 ;************************
                 ;NAME:        audelay_30uS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    SREG
                 ;CALLED BY:   
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             30 uS (assuming a 1 MHz clock).
                 ;********************************************************************
000112 0000      audelay_30uS: nop               ; fine tune delay
000113 0000           nop               ;
000114 938f           push  r24         ; save count reg
000115 e08f           ldi   r24, 0x0f   ; load delay count.
                 aud30_loop:
000116 958a           dec   r24         ; count down to
000117 f7f1           brne  aud30_loop  ; zero.
000118 918f           pop   r24         ; restore orig contents
000119 9508           ret
                 
                 
                 ;**************************
                 ;NAME:        audelay_300uS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R25, SREG
                 ;CALLED BY:   
                 ;DESCRIPTION: This procedure will generate a fixed delay of APPROX
                 ;             300 uS (assuming a 1 MHz clock).
                 ;********************************************************************
                 audelay_300uS:
00011a e09a          ldi   r25, 10        ; loop count = 10 decimal
                 dly_300_loop:
00011b 939f          push  r25 
00011c dff5          rcall audelay_30uS
00011d 919f          pop   r25
00011e 959a          dec   r25            ; count down to
00011f f7d9          brne  dly_300_loop   ; zero.
000120 9508          ret
                 
                 
                 ;*************************************************************
                 ; audelay_1mS - Nested loop delay for creating a delay of 1 mS
                 ; inputs: none
                 ; outputs: none
                 ; alters: nothing
                 ;
                 ; equates for this delay routine
                 .equ outer_cnt11 = 0x18  ; *20* worked (loop ctr val)
                 .equ inner_cnt11 = 0x0d  ; inner loop ctr load value
                 ;
                 ;****************************************************
                 audelay_1mS:
000121 930f          push r16
000122 931f          push r17
000123 e108          ldi  r16,outer_cnt11   ;init outer loop counter value
                 dloop111:
000124 e01d          ldi  r17,inner_cnt11   ;init inner loop counter value
                 dloop222:
000125 951a          dec  r17               ; decr inner count and if
000126 f7f1          brne dloop222          ; 0, fall thru.
000127 950a          dec r16                ; decr outer count, and if
000128 f7d9          brne dloop111          ; 0, fall thru.
000129 911f          pop  r17
00012a 910f          pop  r16
00012b 9508          ret       
                 
                 
                 
                 ;*************************************************************
                 ; audelay_2mS - Nested loop delay for creating a delay of 2 mS
                 ; inputs: none
                 ; outputs: none
                 ; alters: nothing
                 ;
                 ; equates for this delay routine
                 .equ outer_cnt2 = 0x33  ; outer loop counter load value
                 .equ inner_cnt2 = 0x0d  ; inner loop counter load value
                 ;
                 ;***********************************************
                 audelay_2mS:
00012c 930f          push r16
00012d 931f      push r17
00012e e303          ldi  r16,outer_cnt2   ;init outer loop counter value
                 dloop11:
00012f e01d          ldi  r17,inner_cnt2   ;init inner loop counter value
                 dloop22:
000130 951a          dec  r17             ; decr inner count and if
000131 f7f1          brne dloop22          ; 0, fall thru.
000132 950a          dec r16              ; decr outer count, and if
000133 f7d9          brne dloop11          ; 0, fall thru.
000134 911f          pop  r17
000135 910f          pop  r16
000136 9508          ret       
                 
                 
                 ;*********************************************************************
                 ; audelay_10mS - Nested loop delay for creating a 10mS
                 ;                (Useful for software debouncing)
                 ;
                 ; inputs: none
                 ; outputs: none
                 ; alters: nothing
                 ;
                 ; Debouncing delay equate counts
                 .equ o_cnt = 0xf1  ; outer loop counter load value
                 .equ i_cnt = 0x0d  ; inner loop counter load value
                 ;
                 ;***********************************************
                 audelay_10mS:
000137 930f          push r16             ; save registers
000138 931f          push r17
000139 ef01          ldi  r16,o_cnt   ; init outer loop counter value
                 audloop1:
00013a e01d          ldi  r17,i_cnt   ; init inner loop counter value
                 audloop2:
00013b 951a          dec  r17             ; decr inner count and if
00013c f7f1          brne audloop2          ; 0, fall thru.
00013d 950a          dec r16              ; decr outer count, and if
00013e f7d9          brne audloop1          ; 0, fall thru.
00013f 911f          pop  r17             ; restore registers
000140 910f          pop  r16
000141 9508          ret 
                 
                 
                 
                 ;************************
                 ;NAME:        audelay_300mS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22,R23, SREG
                 ;CALLED BY:   init_dsp, ????
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             300 mS.
                 ;********************************************************************
                 audelay_300mS:
000142 e19b           ldi  r25, 27      ; outer loop ctr : *26* was min that worked
                                        ; load count-down value for ~300mS
                 audelay_300ms_loop:
000143 939f           push  r25           ; save loop counter
000144 dff2           rcall audelay_10mS  ; do a 10 mS delay, 35 times
000145 919f           pop   r25           ; restore loop counter
000146 959a           dec   r25           ; dec and check for 0
000147 f7d9           brne  audelay_300ms_loop
000148 9508           ret
                 	 
                 
                 ;************************
                 ; NAME: send_audio_r17r16
                 ; DESC: Each call causes a 16 bit value to be transmitted to 
                 ;   the audio playback module. The 16-bit value can range 
                 ;   from 0x0000 to 0x01ff, providing for the playback of 
                 ;   up to 512 .AD4 audio message files (AMFs). 
                 ;
                 ;  Currently: AMFs 0x0000 to 0x0009 are the matching
                 ;     "number" audio files. So to output an audio "1", 
                 ;     you load r17r16 with 0x0001.  To output an audio "2",
                 ;     load r17:r16 withh 0x0002, and so on. See below for 
                 ;     a full list presently available, pre-recorded
                 ;     audio playback messages
                 ;
                 ; Interface signals:
                 ;    DATA   = PA0    Data out to audio module.
                 ;    DCLK   = PA1    Normally logic 1, Low for 2mS at start.
                 ;    RESET  = PA2    Pulsed low, for 5mS, high for 300 mS
                 ;                    before the clock goes low for 2mS.
                 ;    BUSY   = PA3    Compicated signal!! (300mS delay required
                 ;                    before testing this bit)
                 ;                    1=processing data (busy), 0=ready for data
                 ;
                 ; Assumes: r17:r16 = trigger data to be serially sent. Sound 
                 ;                    files available are as follows:
                 ;
                 ;    r17:r16 =  0x0000 = zero
                 ;            =  0x0001 = one
                 ;            =	0x0002 = two
                 ;                  ...
                 ;                  ...
                 ;            =  0x0009 = nine
                 ;            =  0x000a = 'point'
                 ;            =
                 ;-------------
                 ; Inputs: r17:r16, PA3=Busy status bit
                 ; Outputs: PA0=DATA; PA1=DCK; PA2=RESET (audio module)
                 ; Notes: TIMING FOR THIS MODULE IS CRITICAL & IT IS
                 ;        SUGGESTED THAT THE DELAY TIMES NOT BE ALTERED.
                 ;
                 send_audio_r17r16:
                 check_busy:
000149 99cb           sbic  PinA, 3           ; if BUSY = 1... Wait!
00014a cffe           rjmp  check_busy    ;
00014b dfeb           rcall audelay_10mS  ; **10mS**
                 check_busyy:
00014c 99cb           sbic  PinA, 3           ; if BUSY = 1... Wait!
00014d cffe           rjmp  check_busyy   ;
                 
                 reset_pulse:
00014e 98da           cbi  PortA, 2         ; take RESET of audmo low...
00014f dfd1           rcall audelay_1mS     ; **10mS** must be low for > 5 mS,
000150 9ada           sbi  PortA, 2         ; take RESET back to '1'.
                 
                      ;audelay for 300mS before dclk goes low
000151 dff0           rcall audelay_300mS   ; REQ'D delay of 300mS
                 take_clk_low:
000152 98d9           cbi   PortA, 1        ; take DCLK low, and delay
000153 dfcd           rcall audelay_1mS     ; **1mS** 
                 
                      ;send ZEROs loop
000154 e120           ldi   r18, 0x010    ; load loop counter (16 clocks)
                 send_r17r16_loop:
000155 1f00           rol   r16           ; rotate and test next bit...
000156 1f11           rol   r17           ; (move bit into CY)
000157 f010           brcs  out_one       ; if cy set, brch to output a '1'
000158 98d8           cbi   PortA, 0      ; OK... data bit is '0'
000159 c001           rjmp  pulse_clk     ; jmp and gen clock pulse
                 out_one:
00015a 9ad8           sbi   PortA, 0      ; data bit is '1'
                 pulse_clk:
00015b 98d9           cbi   PortA, 1      ; Take clk low, and
00015c dfc4           rcall audelay_1mS   ; delay for 1mS
00015d 9ad9           sbi   PortA, 1      ; set clock bit high
00015e dfc2           rcall audelay_1mS   ; delay for 2mS
00015f 952a      	 dec   r18           ; check loop counter &
000160 f7a1           brne  send_r17r16_loop  ; jump if NOT zero
                 
                 take_clk_data_high:
000161 9ad9           sbi   PortA, 1      ; Take clk high, and
000162 9ad8           sbi   PortA,0       ; take data high.
000163 dfd3           rcall audelay_10mS  ; delay, and both
000164 dfd2           rcall audelay_10mS  ; SEEM to be REQUIRED!
000165 9508           ret 
                 
                 
                 ;*** END OF AUDIO OUTOUT RELATED ROUTINES ***
                 ;==============================================
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;*********************audio********************************
                 ;puts the value in r16 and r17 and send it to the subroutine
                 ; to make the audio module read the voltage on the screen 
                 ;*******************************************************
                 audio:
000166 930f      	push r16
000167 931f      	push r17
000168 e010      	ldi r17, $00
000169 e000      	ldi r16, $00
00016a 2d0a      	mov r16, r10						;send msb
00016b dfdd      	rcall send_audio_r17r16			;read the voltage, subrouitne
00016c e010      	ldi r17, $00
00016d e00a      	ldi r16, $0A					;send dot
00016e dfda      	rcall send_audio_r17r16			;read the voltage, subrouitne 
00016f e010      	ldi r17, $00
000170 2d07      	mov r16, r7						;send 2nd number
000171 dfd7      	rcall send_audio_r17r16			;read the voltage, subrouitne
000172 e010      	ldi r17, $00
000173 2d06      	mov r16, r6						;send third number
000174 dfd4      	rcall send_audio_r17r16			;read the voltage, subrouitne
000175 e010      	ldi r17, $00
000176 2d05      	mov r16, r5						;send fourth number
000177 dfd1      	rcall send_audio_r17r16			;read the voltage, subrouitne
000178 911f      	pop r17
000179 910f      	pop r16
00017a 9508      	ret
                 ;*********************TIMER INITIALIZATION*************************** 
                 ;_____________________________________________________________________
                 	
                 start_tc1:	
                 //intialization for the timer
                 /*	ldi r16, $00
                 	out TCNT1H, r16						; set up counter with 0's
                 	out TCNT1L, r16			*/		;
                 	;Init Timer/counter Interrupt MaSK (TIMSK) register to enable/set 
00017b e008      	ldi r16, 8							;load with bcd 1000, this will enable the 
                 										;"ocie1b" which is located in bit 4 of the register. 
                 										;refer to datasheet pg 115 for details
00017c bf09      	out TIMSK, r16						;set up the timer interrupt
                 
00017d e200      	ldi r16, 1<<ICF1					;loading the timer interrupt flag register
00017e bf08      	out TIFR, r16						;
                 
                 
00017f e10f      	ldi r16, $1f						;load the counter with 15625
000180 bd09      	out OCR1BH, r16						; so that we will get 1s 
000181 e007      	ldi r16, $07
000182 bd08      	out OCR1BL, r16						;
                 	//sei									;enable global interrupts...
                 
                 
                 	;TCCR1B = FOC0 : WGM11 : COM11 : COM10 : WGM11 : CS12 : CS11 : CS10 
                 	; 0 0 0 0 0 0 1 1 
                 	; FOC Off; No WF Gen; COM=Nrml Port Op; Pre-scaler= 1/64 
                  
                 
000183 9508      	ret
                 
                 	
                 ;*********************spi_setup*******************************
                 ; Get the voltage from max144, by reading the input values for 
                 ; 12 clock cycles. The registers used to store the 12 bits are 
                 ; r8 and r9 
                 
                 spi_setup:
                 
000184 e500      	ldi r16, (1<<spe)|(1<<mstr)
000185 b90d      	out SPCR, r16					;Enable SPI, Master, fck/4,
000186 b10e      	in r16, spsr
000187 b10f      	in r16, spdr 
000188 98c0      	cbi portb, 0
000189 9ac4      	sbi portb, 4
00018a d28f      	rcall delay
00018b ea0a      	ldi r16, $AA
00018c b90f      	out SPDR, r16					;set up dummy value in data register	
                 	wait_H:
00018d 9b77      		sbis spsr, spif
00018e cffe      		rjmp wait_H
00018f b09f      		in r9, spdr
000190 b90f      		out spdr, r16
                 	wait_L:
000191 9b77      		sbis spsr, spif
000192 cffe      		rjmp wait_L
000193 b08f      		in r8, spdr
000194 932f      		push r18
000195 e02f      		ldi r18, $0f
000196 2292      		and r9, r18						;delete first four bits
000197 912f      		pop r18
000198 9ab0      		sbi pinb,0
000199 9ab4      		sbi pinb, 4
00019a 2d28      		mov r18, r8
00019b 2d39      		mov r19, r9
00019c 9508      	ret
                 
                 
                 
                 
                 ;**************************************************************************
                 ;---------------------------- SUBROUTINES ----------------------------
                 
                 ;*********************LCD DISPLAY CODE******************************
                 
                 ;---------------------------------------------------------
                 ;Code to load and display each line on the lcd 
                 ;r25 is used to load the value of the each digit to the pointer
                 ;line 2 refers to table, which containes numbers and depending 
                 ;on the frequncy, each number is picked and displayed 
                 ;---------------------------------------------------------
                 
                 display:
                    
00019d d203         rcall clr_dsp_buffs					; clear all three buffer lines
                    //brtc	run_display
                    //brts hold_display
                 
                 main_menu:
                    ;load 1st line of prompt message into dbuff1
00019e e0f3         ldi  ZH, high(line1_message1<<1)		;
00019f e8e6         ldi  ZL, low(line1_message1<<1)		;
0001a0 d208         rcall load_msg						; load message into buffer(s).
                 
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
0001a1 3050      cpi r21, 0
0001a2 f041      breq menu_run							;if r16 is 1 display run highlighted
0001a3 3051      cpi r21, 1
0001a4 f051      breq menu_hold							;display hold highlighted
0001a5 3052      cpi r21, 2
0001a6 f061      breq menu_capture						;display capture highlighted
0001a7 3053      cpi r21, 3
0001a8 f091      breq menu_alarm
0001a9 3054      cpi r21, 4
0001aa f061      breq menu_freq
                 menu_run:
0001ab e0f3         ldi ZH, high(line2_message_r<<1)		;
0001ac e9e8         ldi ZL, low(line2_message_r<<1)		;load the table to stack
0001ad d1fb         rcall load_msg
0001ae c00f         rjmp thirdline
                 menu_hold:
0001af e0f3         ldi ZH, high(line2_message_h<<1)		;
0001b0 eaea         ldi ZL, low(line2_message_h<<1)		;load the table to stack
0001b1 d1f7         rcall load_msg
0001b2 c00b         rjmp thirdline
                 menu_capture:
0001b3 e0f3         ldi ZH, high(line2_message_c<<1)		;
0001b4 ebec         ldi ZL, low(line2_message_c<<1)		;load the table to stack
0001b5 d1f3         rcall load_msg
0001b6 c007         rjmp thirdline
                  menu_freq:
0001b7 e0f3         ldi ZH, high(line2_message_t<<1)		;
0001b8 eee0         ldi ZL, low(line2_message_t<<1)		;load the table to stack
0001b9 d1ef         rcall load_msg
0001ba c003         rjmp thirdline
                 menu_alarm:
0001bb e0f3         ldi ZH, high(line2_message_a<<1)		;
0001bc ecee         ldi ZL, low(line2_message_a<<1)		;load the table to stack
0001bd d1eb         rcall load_msg
                 thirdline:
                    //rcall load_msg						;load the frequency number into the buffer
                 
                    ;load 3rd line of prompt message into dbuff3
0001be e0f3         ldi  ZH, high(line3_message1<<1)		;
0001bf efe2         ldi  ZL, low(line3_message1<<1)		;
0001c0 d1e8         rcall load_msg						; load message into buffer(s).
0001c1 d1ba         rcall update_lcd_dog
                 
0001c2 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
0001c3 2a01
0001c4 2a2a
0001c5 614d
0001c6 6e69
0001c7 4d20
0001c8 6e65
0001c9 2a75
0001ca 2a2a
0001cb 002a      line1_message1:	.db 1, "***Main Menu****", 0  ; test string for line #1.
0001cc 4604
0001cd 4552
0001ce 2051
0001cf 2020
0001d0 5552
0001d1 204e
0001d2 4820
0001d3 4c4f
0001d4 0044      line2_message_r:.db 4,"FREQ   RUN  HOLD",0
0001d5 5204
0001d6 4e55
0001d7 2020
0001d8 2020
0001d9 4f48
0001da 444c
0001db 2020
0001dc 4143
0001dd 0050      line2_message_h:.db 4,"RUN    HOLD  CAP",0
0001de 4804
0001df 4c4f
0001e0 2044
0001e1 2020
0001e2 4143
0001e3 2050
0001e4 2020
0001e5 4c41
0001e6 004d      line2_message_c:.db 4,"HOLD   CAP   ALM",0
0001e7 4304
0001e8 5041
0001e9 2020
0001ea 2020
0001eb 4c41
0001ec 204d
0001ed 4620
0001ee 4552
0001ef 0051      line2_message_a:.db 4,"CAP    ALM  FREQ",0
0001f0 4104
0001f1 4d4c
0001f2 2020
0001f3 2020
0001f4 5246
0001f5 5145
0001f6 2020
0001f7 5552
0001f8 004e      line2_message_t:.db 4,"ALM    FREQ  RUN",0
0001f9 2003
0001fa 2020
0001fb 2020
0001fc 2020
0001fd 5e5e
0001fe 5e5e
0001ff 2020
000200 2020
000201 0020      line3_message1:	.db 3,"       ^^^^     ", 0  ; test string for line #3.
                 ;*************************************************************************************
                 alarm_select:
                 
                    ;load 1st line of prompt message into dbuff1
000202 e0f4         ldi  ZH, high(line1_message7<<1)		;
000203 e1ea         ldi  ZL, low(line1_message7<<1)		;
000204 d1a4         rcall load_msg						; load message into buffer(s).
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
                 
                 
000205 e0f4         ldi ZH, high(line2_message_7<<1)		;
000206 e2ec         ldi ZL, low(line2_message_7<<1)		;load the table to stack
000207 d1a1         rcall load_msg
                 
                    //rcall load_msg						;load the frequency number into the buffer
                 
                    ;load 3rd line of prompt message into dbuff3
000208 e0f4         ldi  ZH, high(line3_message7<<1)		;
000209 e3ee         ldi  ZL, low(line3_message7<<1)		;
00020a d19e         rcall load_msg						; load message into buffer(s).
00020b d170         rcall update_lcd_dog
00020c 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
00020d 2001
00020e 2020
00020f 2020
000210 2020
000211 2e33
000212 2035
000213 2020
000214 2020
000215 0020      line1_message7:	.db 1,"       3.5      ", 0  ; test string for line #1.
000216 3304
000217 362e
000218 2020
000219 2020
00021a 2020
00021b 2020
00021c 2020
00021d 2e33
00021e 0037      line2_message_7:.db 4,"3.6          3.7",0
00021f 2003
000220 2020
000221 2020
000222 2020
000223 2e33
000224 2038
000225 2020
000226 2020
000227 0020      line3_message7:	.db 3,"       3.8      ", 0  ; test string for line #3.
                 
                  capture_display:
                 
                  // rcall spi_setup
                    ;load 1st line of prompt message into dbuff1
000228 e0f4         ldi  ZH, high(line1_message<<1)		;
000229 e6ea         ldi  ZL, low(line1_message<<1)		;
00022a d17e         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
00022b e0f4         ldi ZH, high(line2_message<<1)		;
00022c e7ec         ldi ZL, low(line2_message<<1)		;load the table to stack
00022d d17b         rcall load_msg			.			;load the frequency number into the buffer
00022e ff71         sbrs r23, 1
00022f c018         rjmp linechange
                 
                    ;load 3rd line of prompt message into dbuff3
000230 e0f4         ldi  ZH, high(line3_message<<1)		;
000231 e7ee         ldi  ZL, low(line3_message<<1)		;
000232 d176         rcall load_msg						; load message into buffer(s).
000233 d148         rcall update_lcd_dog
                 
000234 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
000235 2a01
000236 2a2a
000237 2a2a
000238 6f56
000239 746c
00023a 6761
00023b 2a65
00023c 2a2a
00023d 002a      line1_message:	.db 1, "*****Voltage****", 0  ; test string for line #1.
00023e 0002      line2_message:	.db 2,"",0
00023f 4303
000240 5041
000241 5554
000242 4552
000243 2020
000244 2020
000245 2020
000246 666f
000247 0066      line3_message:	.db 3, "CAPTURE      off", 0  ; test string for line #3.
                 
                 
                  linechange: 
                    ;load 3rd line of prompt message into dbuff3
000248 e0f4         ldi  ZH, high(line3_message0<<1)		;
000249 eaee         ldi  ZL, low(line3_message0<<1)		;
00024a d15e         rcall load_msg						; load message into buffer(s).
00024b d130         rcall update_lcd_dog
                 
00024c 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
00024d 2a01
00024e 2a2a
00024f 2a2a
000250 6f56
000251 746c
000252 6761
000253 2a65
000254 2a2a
000255 002a      line1_message0:	.db 1, "*****Voltage****", 0  ; test string for line #1.
000256 0002      line2_message0:	.db 2,"",0
000257 4303
000258 7061
000259 7574
00025a 6572
00025b 2020
00025c 2020
00025d 2020
00025e 6f20
00025f 006e      line3_message0:	.db 3, "Capture       on", 0  ; test string for line #3.
                 
                 ;**************************************************************************************
                   run_display:
                 
                    ;load 1st line of prompt message into dbuff1
000260 e0f4         ldi  ZH, high(line1_message2<<1)		;
000261 ede6         ldi  ZL, low(line1_message2<<1)		;
000262 d146         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
000263 e0f4         ldi ZH, high(line2_message2<<1)		;
000264 eee8         ldi ZL, low(line2_message2<<1)		;load the table to stack
000265 d143         rcall load_msg						;load the frequency number into the buffer
                    
                 
                    ;load 3rd line of prompt message into dbuff3
000266 e0f4         ldi  ZH, high(line3_message2<<1)		;
000267 eeea         ldi  ZL, low(line3_message2<<1)		;
000268 d140         rcall load_msg						; load message into buffer(s).
000269 d112         rcall update_lcd_dog
00026a 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
00026b 2a01
00026c 2a2a
00026d 2a2a
00026e 6f56
00026f 746c
000270 6761
000271 2a65
000272 2a2a
000273 002a      line1_message2:	.db 1, "*****Voltage****", 0  ; test string for line #1.
000274 0002      line2_message2:	.db 2,"",0
000275 5203
000276 4e55
000277 2020
000278 2020
000279 2020
00027a 2020
00027b 4d20
00027c 444f
00027d 0045      line3_message2:	.db 3, "RUN         MODE", 0  ; test string for line #3.
                 
                 ;***************************************************************************************
                 ;**************************************************************************************
                   hold_display:
                 
                    ;load 1st line of prompt message into dbuff1
00027e e0f5         ldi  ZH, high(line1_message3<<1)		;
00027f e1e2         ldi  ZL, low(line1_message3<<1)		;
000280 d128         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
000281 e0f5         ldi ZH, high(line2_message3<<1)		;
000282 e2e4         ldi ZL, low(line2_message3<<1)		;load the table to stack
000283 d125         rcall load_msg						;load the frequency number into the buffer
                    
                 
                    ;load 3rd line of prompt message into dbuff3
000284 e0f5         ldi  ZH, high(line3_message3<<1)		;
000285 e2e6         ldi  ZL, low(line3_message3<<1)		;
000286 d122         rcall load_msg						; load message into buffer(s).
000287 d0f4         rcall update_lcd_dog
000288 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
000289 2a01
00028a 2a2a
00028b 2a2a
00028c 6f56
00028d 746c
00028e 6761
00028f 2a65
000290 2a2a
000291 002a      line1_message3:	.db 1, "*****Voltage****", 0  ; test string for line #1.
000292 0002      line2_message3:	.db 2,"",0
000293 4803
000294 4c4f
000295 2044
000296 2020
000297 2020
000298 2020
000299 4d20
00029a 444f
00029b 0045      line3_message3:	.db 3, "HOLD        MODE", 0  ; test string for line #3.
                 ;*****************************************************************************
                 alarm_display:
                 
                 
                    ;load 1st line of prompt message into dbuff1
00029c e0f5         ldi  ZH, high(line1_message6<<1)		;
00029d e4ee         ldi  ZL, low(line1_message6<<1)		;
00029e d10a         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
00029f e0f5         ldi ZH, high(line2_message6<<1)		;
0002a0 e6e0         ldi ZL, low(line2_message6<<1)		;load the table to stack
0002a1 d107         rcall load_msg			.			;load the frequency number into the buffer
                    
                 
                    ;load 3rd line of prompt message into dbuff3
0002a2 e0f5         ldi  ZH, high(line3_message6<<1)		;
0002a3 e6e2         ldi  ZL, low(line3_message6<<1)		;
0002a4 d104         rcall load_msg						; load message into buffer(s).
0002a5 d0d6         rcall update_lcd_dog
                 
0002a6 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
0002a7 2a01
0002a8 2a2a
0002a9 2a2a
0002aa 6f56
0002ab 746c
0002ac 6761
0002ad 2a65
0002ae 2a2a
0002af 002a      line1_message6:	.db 1, "*****Voltage****", 0  ; test string for line #1.
0002b0 0002      line2_message6:	.db 2,"",0
0002b1 4103
0002b2 414c
0002b3 4d52
0002b4 2020
0002b5 2020
0002b6 2020
0002b7 4d20
0002b8 444f
0002b9 0045      line3_message6:	.db 3, "ALARM       MODE", 0  ; test string for line #3.
                 ;*****************************************************************************
                  overflow: 
                    ;load 3rd line of prompt message into dbuff3
0002ba e0f5         ldi  ZH, high(line2_message5<<1)		;
0002bb e9e0         ldi  ZL, low(line2_message5<<1)		;
0002bc d0ec         rcall load_msg						; load message into buffer(s).
0002bd d0be         rcall update_lcd_dog
                 
0002be 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
0002bf 2a01
0002c0 2a2a
0002c1 2a2a
0002c2 6f56
0002c3 746c
0002c4 6761
0002c5 2a65
0002c6 2a2a
0002c7 002a      line1_message5:	.db 1, "*****Voltage****", 0  ; test string for line #1.
0002c8 2004
0002c9 766f
0002ca 7265
0002cb 7420
0002cc 6568
0002cd 6c20
0002ce 6d69
0002cf 7469
0002d0 0020      line2_message5:	.db 4, " over the limit ",0
0002d1 2003
0002d2 2020
0002d3 2020
0002d4 2020
0002d5 2020
0002d6 2020
0002d7 2020
0002d8 2020
0002d9 0020      line3_message5:	.db 3, "                ", 0  ; test string for line #3.
                 ;********************************************************************************
                 freq_display:
                 
                    ;load 1st line of prompt message into dbuff1
0002da e0f5         ldi  ZH, high(line1_message8<<1)		;
0002db ecea         ldi  ZL, low(line1_message8<<1)		;
0002dc d0cc         rcall load_msg						; load message into buffer(s).
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
0002dd e0f5         ldi ZH, high(line2_message8<<1)		;
0002de edec         ldi ZL, low(line2_message8<<1)		;load the table to stack
0002df d0c9         rcall load_msg						;load the frequency number into the buffer
                    
                    ;load 3rd line of prompt message into dbuff3
0002e0 e0f5         ldi  ZH, high(line3_message8<<1)		;
0002e1 edee         ldi  ZL, low(line3_message8<<1)		;
0002e2 d0c6         rcall load_msg						; load message into buffer(s).
0002e3 d098         rcall update_lcd_dog
0002e4 9508         ret
                 
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
0002e5 2a01
0002e6 2a2a
0002e7 5246
0002e8 5145
0002e9 4555
0002ea 434e
0002eb 2a59
0002ec 2a2a
0002ed 002a      line1_message8:	.db 1, "***FREQUENCY****", 0  ; test string for line #1.
0002ee 0005      line2_message8:	.db 5,"",0
0002ef 4b03
0002f0 5a48
0002f1 2020
0002f2 2020
0002f3 2020
0002f4 3020
0002f5 352e
0002f6 4553
0002f7 0043      line3_message8:	.db 3, "KHZ       0.5SEC", 0  ; test string for line #3.
                 ;*******************************************************************************************
                 backlight_display:
                 
                 
                    ;load 1st line of prompt message into dbuff1
0002f8 e0f6         ldi  ZH, high(line1_message10<<1)		;
0002f9 e0ee         ldi  ZL, low(line1_message10<<1)		;
0002fa d0ae         rcall load_msg						; load message into buffer(s).
                 
                   //sbrs r24, 1
                   //rjmp linechange1
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
0002fb e0f6         ldi ZH, high(line2_message10<<1)		;
0002fc e2e0         ldi ZL, low(line2_message10<<1)		;load the table to stack
0002fd d0ab         rcall load_msg			.			;load the frequency number into the buffer
                 
                 
                    ;load 3rd line of prompt message into dbuff3
0002fe e0f6         ldi  ZH, high(line3_message10<<1)		;
0002ff e4e4         ldi  ZL, low(line3_message10<<1)		;
000300 d0a8         rcall load_msg						; load message into buffer(s).
000301 d07a         rcall update_lcd_dog
000302 9508         ret
                 
                   linechange1:
000303 e0f6         ldi  ZH, high(line21_message10<<1)		;
000304 e3e2         ldi  ZL, low(line21_message10<<1)		;
000305 d0a3         rcall load_msg						; load message into buffer(s).
000306 d075         rcall update_lcd_dog
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
000307 4201
000308 4341
000309 4c4b
00030a 4749
00030b 5448
00030c 2020
00030d 4320
00030e 5254
00030f 004c      line1_message10:	.db 1, "BACKLIGHT   CTRL", 0  ; test string for line #1.
000310 2004
000311 2020
000312 2020
000313 4e45
000314 4241
000315 454c
000316 2044
000317 2020
000318 0020      line2_message10:	.db 4, "     ENABLED    ",0
000319 2004
00031a 2020
00031b 4420
00031c 5349
00031d 4241
00031e 454c
00031f 2044
000320 2020
000321 0020      line21_message10:	.db 4, "    DISABLED    ",0
000322 3503
000323 2073
000324 4920
000325 414e
000326 5443
000327 5649
000328 2045
000329 464f
00032a 0046      line3_message10:	.db 3, "5s  INACTIVE OFF", 0  ; test string for line #3.
                 ;*************************************************************************************
                 ;====================================
                 .include "lcd_dog_asm_driver_m16A.inc"  ; LCD DOG init/update procedures.
                 
                 ;modified 11/26/12 KLS
                 ; lcd_spi_transmit_data and lcd_spi_transmit_CMD handling of SPIF flag
                 ;
                 ;modifued 07/21/14 FST
                 ; added BLOCK comments for adjusting power_ctrl & contrast_set parameters
                 ;
                 
                 
                 ;************************************************************************ 
                 ;   ATMega16A  2015 Version                           PRINT IN LANDSCAPE                     
                 ;   
                 ;   This AVR-asm code module is usable as an include file for assembly
                 ;   language and or mixed asm/C application programs. The code is freely 
                 ;   usable by any University of Stonybrook undergraduate students for any
                 ;   and all not-for-profit system designs and or implementations.
                 ;
                 ;   This code is designed to be executed on an AVR ATMega micro-computer.
                 ;   And may be readily adapted for compatibility with IAR/AVR compilers. 
                 ;   See the IAR assembler reference guide for more information by 
                 ;   clicking 'Help > AVR Assembly Reference Guide" on the above menus.
                 ;
                 ;
                 ;************************************************************************
                 ;
                 ;   This module contains procedures to initialize and update
                 ;   DOG text based LCD display modules, including the EA DOG163M LCD
                 ;   modules configured with three (3) 16 charactors display lines.
                 ;
                 ;   The display module hardware interface uses a 1-direction, write only
                 ;   SPI interface. (See below for more information.)
                 ;
                 ;   The display module software interface uses three (3) 16-byte
                 ;   data (RAM) based display buffers - One for each line of the display.
                 ;   (See below for more information.)
                 ;
                 ;*********************************************************************
                 ;
                 ;   *** Port B Interface Definitions:
                 ;
                 ;  Port B             PB7   PB6   PB5   PB4   PB3   PB2   PB1   PB0
                 ;  Port B alt names   SCK   MISO  MOSI  /SS   /RS    -     -     -
                 ;  LCD Mod Signal     D6     -     D7   /CSB   -     -     -     -
                 ;  LCD Mod Pin #      29     -     28    38    -     -     -     -
                 ;
                 ;  Notes: RS ==>  0 = command regs, 1 = data regs
                 ;         /SS = active low SPI select signal
                 ;
                 ;******************
                 
                 
                 ;***  DATA Segment  **************************************************   
                 .DSEG
000060           dsp_buff_1:   .byte 16
000070           dsp_buff_2:   .byte 16
000080           dsp_buff_3:   .byte 16
                 
                 
                 
                 
                 ;***  CODE Segment Subroutines  ************************************
                 .CSEG
                 
                 
                 
                 ;************************
                 ;NAME:        delay_30uS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R24, SREG
                 ;CALLED BY:   init_dsp
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             30 uS (assuming a 1 MHz clock).
                 ;********************************************************************
00032b 0000      delay_30uS:   nop     ; fine tune delay
00032c 0000                    nop
00032d 938f                    push  r24
00032e e08f                    ldi   r24, 0x0f  ; load delay count.
00032f 958a      d30_loop:     dec   r24        ; count down to
000330 f7f1                    brne  d30_loop   ; zero.
000331 918f                    pop   r24
000332 9508                    ret
                 
                 
                 
                 ;*********************
                 ;NAME:        v_delay
                 ;ASSUMES:     R22, R23 = initial count values defining how many
                 ;             30uS delays will be called. This procedure can generate
                 ;             short delays (r23 = small #) or much longer delays (where
                 ;             R23 value is large).
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22, R23, SREG
                 ;CALLED BY:   init_dsp, plus...
                 ;DESCRIPTION: This procedure will generate a variable delay for a fixed
                 ;             period of time based the values pasted in R24 and R25.
                 ;
                 ;Sample Delays:
                 ;
                 ;             R22  R23  DelayTime
                 ;             ---  ---  ---------
                 ;              1    1   ~65.5 uS
                 ;              0    1   ~14.2 mS
                 ;              0    9   ~130 mS
                 ;**********************************************************************
000333 dff7      v_delay:      rcall delay_30uS ; delay for ~30uS
000334 956a                    dec   r22      ; decrement inner loop value, and
000335 f7e9                    brne  v_delay  ; loop until zero.
000336 957a                    dec   r23      ; decr outer loop count, and loop back
000337 f7d9                    brne  v_delay  ; to inner loop delay until r23 zero.
000338 9508                    ret
                 
                 
                 
                 
                 ;***********************
                 ;NAME:        delay_40mS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22,R23, SREG
                 ;CALLED BY:   init_dsp, ????
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             40 mS.
                 ;********************************************************************
000339 e060      delay_40mS:   ldi   r22,0        ; load inner loop var
00033a e074                    ldi   r23,4        ; load outer loop var
00033b dff7                    rcall  v_delay     ; delay
00033c 9508                    ret
                 
                 
                 
                 
                 ;************************
                 ;NAME:       init_spi_lcd
                 ;ASSUMES:    IMPORTANT: PortB set as output (during program init)
                 ;RETURNS:    nothing
                 ;MODIFIES:   DDRB, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: init SPI port for command and data writes to LCD via SPI
                 ;********************************************************************
                 init_spi_lcd:
00033d 930f            push r16
00033e e50c            ldi r16,(1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA)
00033f b90d            out SPCR,r16   ; Enable SPI, Master, fck/4, 
                       
                       ;kill any spurious data...
000340 b10e            in r16, SPSR   ; clear SPIF bit in SPSR
000341 b10f            in r16, SPDR   ;
000342 910f            pop r16        ; restore r16 value...
000343 9508            ret
                 
                 
                 
                 ;********************************
                 ;NAME:       lcd_spi_transmit_CMD
                 ;ASSUMES:    r16 = byte for LCD.
                 ;            SPI port is configured.
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, PortB, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: outputs a byte passed in r16 via SPI port. Waits for data
                 ;            to be written by spi port before continuing.
                 ;*********************************************************************
                 lcd_spi_transmit_CMD:
000344 930f           push r16          ; save command, need r16.
000345 98c3           cbi   portB, 3    ; clr PB1 = RS = 0 = command.
000346 98c4           cbi   portB, 4    ; clr PB2 = /SS = selected.
000347 b10e              in r16, SPSR   ; clear SPIF bit in SPSR.
000348 b10f              in r16, SPDR   ;
000349 910f           pop r16           ; restore command
00034a b90f           out SPDR,r16      ; write data to SPI port.
                 
                 
                      ;Wait for transmission complete
                 wait_transmit:
00034b b10e           in r16, SPSR     ; read status reg
00034c ff07           sbrs r16, SPIF   ; if bit 7  = 0 wait
00034d cffd           rjmp wait_transmit
00034e b10f      	 in r16, SPDR		;added by Ken to clear SPIF
00034f 9ac4           sbi   portB, 4   ; set PB2 = /SS = deselected
000350 9508           ret
                 
                 
                 
                 
                 ;*********************************
                 ;NAME:       lcd_spi_transmit_DATA
                 ;ASSUMES:    r16 = byte to transmit to LCD.
                 ;            SPI port is configured.
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: outputs a byte passed in r16 via SPI port. Waits for
                 ;            data to be written by spi port before continuing.
                 ;*****************************************************************
                 lcd_spi_transmit_DATA:
000351 930f           push r16          ; save command, need r16.
000352 9ac3           sbi   portB, 3    ; clr PB1 = RS = 1 = data.
000353 98c4           cbi   portB, 4    ; clr PB2 = /SS = selected.
000354 b10e              in r16, SPSR   ; clear SPIF bit in SPSR.
000355 b10f              in r16, SPDR   ;
000356 910f           pop r16           ; restore command.
000357 b90f           out SPDR,r16      ; write data to SPI port.
                 
                 
                      ;Wait for transmission complete
                 wait_transmit1:
000358 b10e           in r16, SPSR     ; read status reg
000359 ff07           sbrs r16, SPIF   ; if bit 7  = 0 wait
00035a cffd           rjmp wait_transmit1
00035b b10f      	 in r16, SPDR		;clear SPIF (because it follows in r16,SPSR)
00035c 9ac4           sbi   portB, 4   ; set PB2 = /SS = deselected
00035d 9508           ret
                 
                 
                 
                 ;************************
                 ;NAME:       init_lcd_dog
                 ;ASSUMES:    nothing
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, R17
                 ;CALLED BY:  main application
                 ;DESCRITION: inits DOG module LCD display for SPI (serial) operation.
                 ;NOTE:  Can be used as is with MCU clock speeds of 4MHz or less.
                 ;********************************************************************
                 ; public __version_1 void init_dsp(void)
                 init_lcd_dog:
00035e dfde             rcall init_spi_lcd   ; init SPI port for DOG LCD.
                 
                 
                 start_dly_40ms:
00035f dfd9             rcall  delay_40mS    ; startup delay.
                 
                 
                 func_set1:
000360 e309             ldi    r16,0x39      ; send fuction set #1
000361 dfe2             rcall  lcd_spi_transmit_CMD   ;
000362 dfc8             rcall  delay_30uS    ; delay for command to be processed
                 
                 
                 func_set2:
000363 e309             ldi    r16,0x39      ; send fuction set #2
000364 dfdf             rcall  lcd_spi_transmit_CMD
000365 dfc5             rcall  delay_30uS    ; delay for command to be processed
                 
                 
                 bias_set:
000366 e10e             ldi    r16,0x1E      ; set bias value.
000367 dfdc             rcall  lcd_spi_transmit_CMD
000368 dfc2             rcall  delay_30uS    ;
                 
                 
                                                    ; =============================================
                                                    ; === CALIBRATION PARAMETER - USER ADJUSTABLE
                 power_ctrl:                        ; === (CAUTION... VERY DELICATE ADJUSTMENT)
000369 e500             ldi    r16,0x50             ; === 5V ~= 0x50 nominal;      Adjust by 1 ONLY
00036a dfd9             rcall  lcd_spi_transmit_CMD ; === 3.3V ~= 0x55 nominal     and think hex!
00036b dfbf             rcall  delay_30uS           ;   Hex = 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f
                                                    ; ==========================================
                 
                 follower_ctrl:
00036c e60c             ldi    r16,0x6C      ; follower mode on... 
00036d dfd6             rcall  lcd_spi_transmit_CMD
00036e dfca             rcall  delay_40mS    ;
                                                    ; ============================================
                                                    ; === CALIBRATION PARAMETER - USER ADJUSTABLE
                 contrast_set:                      ; === LCD CONTRAST SETTING ADJUSTMENT
00036f e707             ldi    r16,0x77             ; === 
000370 dfd3             rcall  lcd_spi_transmit_CMD ; === Delicate: increases for 3.3V vs 5V
000371 dfb9             rcall  delay_30uS           ; ========================================= 
                 
                 display_on:
000372 e00c             ldi    r16,0x0c      ; display on, cursor off, blink off
000373 dfd0             rcall  lcd_spi_transmit_CMD
000374 dfb6             rcall  delay_30uS    ; 
                 
                 
                 clr_display:
000375 e001             ldi    r16,0x01      ; clear display, cursor home
000376 dfcd             rcall  lcd_spi_transmit_CMD
                 
                 
000377 dfb3             rcall  delay_30uS    ;
                 
                 
                 entry_mode:
000378 e006             ldi    r16,0x06      ; clear display, cursor home
000379 dfca             rcall  lcd_spi_transmit_CMD;
00037a dfb0             rcall  delay_30uS    ;
00037b 9508             ret
                 
                 
                 
                 
                 ;**************************
                 ;NAME:       update_lcd_dog
                 ;ASSUMES:    display buffers loaded with display data
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16,R20,R30,R31,SREG
                 ;
                 ;DESCRITION: Updates the LCD display lines 1, 2, and 3, using the
                 ;  contents of dsp_buff_1, dsp_buff_2, and dsp_buff_3, respectively.
                 ;*******************************************************************
                 ; public __version_1 void update_dsp_dog (void)
                 update_lcd_dog:
00037c dfc0             rcall init_spi_lcd    ; init SPI port for LCD.
00037d e140             ldi   r20,16          ; init 'chars per line' counter.
00037e 934f             push  r20             ; save for later used.
                 
                 
                        ;send line 1 to the LCD module.
                 wr_line1:     
00037f e0f0             ldi   ZH, high (dsp_buff_1)  ; init ptr to line 1 display buffer.
000380 e6e0             ldi   ZL, low (dsp_buff_1)   ;
                 snd_ddram_addr:
000381 e800             ldi   r16,0x80             ; init DDRAM addr-ctr 
000382 dfc1             rcall lcd_spi_transmit_CMD ; 
000383 dfa7             rcall delay_30uS
                 snd_buff_1:
000384 9101             ld    r16, Z+
000385 dfcb             rcall lcd_spi_transmit_DATA
000386 dfa4             rcall delay_30uS
000387 954a             dec   r20
000388 f7d9             brne  snd_buff_1
                 
                 
                        ;send line 2 to the LCD module.
                 init_for_buff_2:
000389 914f             pop   r20     ; reload r20 = chars per line counter
00038a 934f             push  r20     ; save for line 3
                 wr_line2:
00038b e0f0             ldi   ZH, high (dsp_buff_2)  ; init ptr to line 2 display buffer.
00038c e7e0             ldi   ZL, low (dsp_buff_2)
                 snd_ddram_addr2:
00038d e900             ldi   r16,0x90               ; init DDRAM addr-ctr 
00038e dfb5             rcall lcd_spi_transmit_CMD           ;  
00038f df9b             rcall delay_30uS
                 snd_buff_2:
000390 9101             ld    r16, Z+
000391 dfbf             rcall lcd_spi_transmit_DATA
000392 df98             rcall delay_30uS
000393 954a             dec   r20
000394 f7d9             brne  snd_buff_2
                 
                 
                        ;send line 3 to the LCD module.
                 init_for_buff_3:
000395 914f             pop   r20     ; reload r20 = chars per line counter
                 wr_line3:
000396 e0f0             ldi   ZH, high (dsp_buff_3)  ; init ptr to line 2 display buffer.
000397 e8e0             ldi   ZL, low (dsp_buff_3)
                 snd_ddram_addr3:
000398 ea00             ldi   r16,0xA0               ; init DDRAM addr-ctr 
000399 dfaa             rcall lcd_spi_transmit_CMD           ;  
00039a df90             rcall delay_30uS
                 
                 
                 snd_buff_3:
00039b 9101             ld    r16, Z+
00039c dfb4             rcall lcd_spi_transmit_DATA
00039d df8d             rcall delay_30uS
00039e 954a             dec   r20
00039f f7d9             brne  snd_buff_3
0003a0 9508             ret
                 
                 
                 ;******* End Of LCD DOG Include Module *********************************
                 ;====================================
                 
                 ;************************
                 ;NAME:      clr_dsp_buffs
                 ;FUNCTION:  Initializes dsp_buffers 1, 2, and 3 with blanks (0x20)
                 ;ASSUMES:   Three CONTIGUOUS 16-byte dram based buffers named
                 ;           dsp_buff_1, dsp_buff_2, dsp_buff_3.
                 ;RETURNS:   nothing.
                 ;MODIFIES:  r25,r26, Z-ptr
                 ;CALLS:     none
                 ;CALLED BY: main application and diagnostics
                 ;********************************************************************
                 clr_dsp_buffs:
0003a1 e390           ldi R25, 48						; load total length of both buffer.
0003a2 e2a0           ldi R26, ' '						; load blank/space into R26.
0003a3 e0f0           ldi ZH, high (dsp_buff_1)			; Load ZH and ZL as a pointer to 1st
0003a4 e6e0           ldi ZL, low (dsp_buff_1)			; byte of buffer for line 1.
                    
                     ;set DDRAM address to 1st position of first line.
                 store_bytes:
0003a5 93a1           st  Z+, R26						; store ' ' into 1st/next buffer byte and
                 										; auto inc ptr to next location.
0003a6 959a           dec  R25							; 
0003a7 f7e9           brne store_bytes					; cont until r25=0, all bytes written.
0003a8 9508           ret
                 
                 
                 ;*******************
                 ;NAME:      load_msg
                 ;FUNCTION:  Loads a predefined string msg into a specified diplay
                 ;           buffer.
                 ;ASSUMES:   Z = offset of message to be loaded. Msg format is 
                 ;           defined below.
                 ;RETURNS:   nothing.
                 ;MODIFIES:  r16, Y, Z
                 ;CALLS:     nothing
                 ;CALLED BY:  
                 ;********************************************************************
                 ; Message structure:
                 ;   label:  .db <buff num>, <text string/message>, <end of string>
                 ;
                 ; Message examples (also see Messages at the end of this file/module):
                 ;   msg_1: .db 1,"First Message ", 0   ; loads msg into buff 1, eom=0
                 ;   msg_2: .db 1,"Another message ", 0 ; loads msg into buff 1, eom=0
                 ;
                 ; Notes: 
                 ;   a) The 1st number indicates which buffer to load (either 1, 2, or 3).
                 ;   b) The last number (zero) is an 'end of string' indicator.
                 ;   c) Y = ptr to disp_buffer
                 ;      Z = ptr to message (passed to subroutine)
                 ;********************************************************************
                 load_msg:
0003a9 93af      	 push r26
0003aa 931f      	 push r17
0003ab e0d0           ldi YH, high (dsp_buff_1)			; Load YH and YL as a pointer to 1st
0003ac e6c0           ldi YL, low (dsp_buff_1)			; byte of dsp_buff_1 (Note - assuming 
                 										; (dsp_buff_1 for now).
0003ad 9105           lpm R16, Z+						; get dsply buff number (1st byte of msg).
0003ae 3001           cpi r16, 1							; if equal to '1', ptr already setup.
0003af f061           breq get_msg_byte					; jump and start message load.
0003b0 9660           adiw YH:YL, 16						; else set ptr to dsp buff 2.
0003b1 e010      	 ldi r17, $00
0003b2 e0a6      	 ldi r26, 6
0003b3 3002           cpi r16, 2							; if equal to '2', ptr now setup.
0003b4 f061           breq digit_load					; jump and start message load.
0003b5 e010      	 ldi r17, $00
0003b6 e0a6      	 ldi r26, 6
0003b7 3005           cpi r16, 5							; if equal to '2', ptr now setup.
0003b8 f041           breq digit_load					; jump and start message load.
0003b9 3004      	 cpi r16, 4
0003ba f009      	 breq get_msg_byte
0003bb 9660           adiw YH:YL, 16						; else set ptr to dsp buff 3.
                         
                 get_msg_byte:
0003bc 9105           lpm R16, Z+						; get next byte of msg and see if '0'.        
0003bd 3000           cpi R16, 0							; if equal to '0', end of message reached.
0003be f121           breq msg_loaded					; jump and stop message loading operation.
0003bf 9309           st Y+, R16							; else, store next byte of msg in buffer.
0003c0 cffb           rjmp get_msg_byte					; jump back and continue...
                 
                 ;__________________________________________
                 ; digital_load will only be accessed when displaying line 2, 
                 ; since the frequency to be displayed in line 2 is constantly 
                 ; changing for different waveform, the line 2 has to be adjusted 
                 ; according. 
                 ; r17, will inc until 6, to display 6 empty spaces
                 ; r4 will contain the first digit of the frequency
                 ; r3 will contain the second digit of the frequency
                 ; r2 will contain the third digit of the frequency
                 ; r1 will contian the fouth digit of the frequency
                 ;get_dis_freq subroutine will just transfer each value stored in 
                 ; r25 to y pointer
                 ;_______________________________________________	
                 digit_load:
0003c1 e0b5      	ldi r27, 5
0003c2 9513      	inc r17
0003c3 e290      	ldi r25, $20					;load empty spaces for 6 places
0003c4 d01c      	rcall get_dis_freq				;display 
0003c5 131a      	cpse r17, r26					;check if 6 places typed
0003c6 cffa      	rjmp digit_load					;repeat until 6 places
                 	;mov r25, r5						;load the first number in freq
                 	;rcall get_dis_freq				;display 
0003c7 2d94      	mov r25, r4					;load the first number in freq
0003c8 d018      	rcall get_dis_freq				;display 
0003c9 e29e      	ldi r25, $2E
0003ca d016      	rcall get_dis_freq				;load period to display inbetween numbers
0003cb 2d93      	mov r25, r3					;load the second number in freq
0003cc d014      	rcall get_dis_freq				;display 
0003cd 2d92      	mov r25, r2						;load the third number in freq
0003ce d012      	rcall get_dis_freq				;display 
0003cf 2d91      	mov r25, r1						;load the fourth number in freq
0003d0 d010      	rcall get_dis_freq				;display 
0003d1 130b      	cpse r16, r27
0003d2 d00b      	rcall disp_volts				;display
0003d3 e290      	ldi r25, $20					;load empty spaces for 6 places
0003d4 d00c      	rcall get_dis_freq				;display 
0003d5 e290      	ldi r25, $20					;load empty spaces for 6 places
0003d6 d00a      	rcall get_dis_freq				;display 
0003d7 e290      	ldi r25, $20					;load empty spaces for 6 places
0003d8 d008      	rcall get_dis_freq				;display 
0003d9 e290      	ldi r25, $20					;load empty spaces for 6 places
0003da d006      	rcall get_dis_freq				;display 
0003db e290      	ldi r25, $20					;load empty spaces for 6 places
0003dc d004      	rcall get_dis_freq				;display 
0003dd c005      	rjmp msg_loaded					;go to the next line of the lcd
                 
                 disp_volts:
0003de e596      	ldi r25, $56					;load the fourth number in freq
0003df d001      	rcall get_dis_freq				;display 
0003e0 9508      	ret
                 get_dis_freq:
0003e1 9399      	st Y+, r25						;display the selected frquency
0003e2 9508      	ret		
                 
                 	
                 msg_loaded:
0003e3 911f      	 pop r17
0003e4 91af      	 pop r26
0003e5 9508           ret
                 ;________________________________________________________________________________________
                 
                 ;------------------------------------------------
                 ;unpacks the values store in r8 and r9 to r1- r4
                 ; r4 containe the left most number ie the thousanth
                 ;digit and r1 the right most number
                 ;------------------------------------------------
                 ;------------------------------------------------
                 ;unpacks the values store in r13 and r14 to r1- r4
                 ; r4 containe the left most number ie the thousanth
                 ;digit and r1 the right most number
                 ;------------------------------------------------
                 .def bit01 = r13				;values taken from bin2bcd
                 .def bit23 = r14
                 unpack:
0003e6 d018      	rcall bin2BCD16					;convert the values from binary to bcd
0003e7 930f      	push r16						;store the value currently in r16
0003e8 2c2d      	mov r2, bit01					;make a copy of r13 in r2
0003e9 2c4e      	mov r4, bit23					;make a copy of r14 in r4
0003ea e00f      	ldi r16, $0f					;use and function to
0003eb 22d0      	and bit01, r16					;mask the upper nibble of r8
0003ec 2c1d      	mov r1, bit01					;move lower nibble to r1
0003ed 22e0      	and bit23, r16					;mask upper nibble of r9
0003ee 2c3e      	mov r3, bit23					;move lower nible to r3
0003ef 9500      	com r16							;load with f0 to mask lower nibble
0003f0 2220      	and r2, r16						;mask lower nibble of r8
0003f1 9422      	swap r2							;switch upper and lower nibble
0003f2 2240      	and r4, r16						;mask lower nibble of r9
0003f3 9442      	swap r4							;switch upper and lower nibble
                 
0003f4 2ca4      	mov r10, r4
0003f5 2c73      	mov r7, r3
0003f6 2c62      	mov r6, r2
0003f7 2c51      	mov r5, r1						;copy the bcd values to r8-r5
0003f8 e300      	ldi r16, $30
0003f9 0e10      	add r1, r16
0003fa 0e20      	add r2, r16
0003fb 0e30      	add r3, r16
0003fc 0e40      	add r4, r16
0003fd 910f      	pop r16							;retrive the value previosly stored
0003fe 9508      	ret
                 
                 .undef bit01 
                 .undef bit23	
                 		
                 
                 
                 
                 
                 
                 
                 
                 ;_____________________________________________________________________________________
                 
                 
                 
                 
                 
                 ;***************************************************************************
                 ;*
                 ;* "bin2BCD16" - 16-bit Binary to BCD conversion
                 ;*
                 ;* This subroutine converts a 16-bit number (fbinH:fbinL) to a 5-digit
                 ;* packed BCD number represented by 3 bytes (tBCD2:tBCD1:tBCD0).
                 ;* MSD of the 5-digit number is placed in the lowermost nibble of tBCD2.
                 ;*
                 ;* Number of words	:25
                 ;* Number of cycles	:751/768 (Min/Max)
                 ;* Low registers used	:3 (tBCD0,tBCD1,tBCD2)
                 ;* High registers used  :4(fbinL,fbinH,cnt16a,tmp16a)	
                 ;* Pointers used	:Z
                 ;*
                 ;***************************************************************************
                 //.include "..\8515def.inc"
                 ;***** Subroutine Register Variables
                 
                 
                 .equ	AtBCD0	=13			;address of tBCD0
                 .equ	AtBCD2	=15			;address of tBCD1
                 
                 .def	tBCD0	=r13		;BCD value digits 1 and 0
                 .def	tBCD1	=r14		;BCD value digits 3 and 2
                 .def	tBCD2	=r15		;BCD value digit 4
                 .def	fbinL	=r16		;binary value Low byte
                 .def	fbinH	=r17		;binary value High byte
                 .def	cnt16a	= r18		;loop counter
                 .def	tmp16a	= r19		;temporary value
                 
                 ;***** Code
                 
                 bin2BCD16:
                 	//sub r18, r19
0003ff 2f13      	mov fbinH, r19			;copy the values of edge counter to fbin
000400 2f02      	mov fbinL, r18
000401 e120      	ldi	cnt16a, 16			;Init loop counter	
000402 24ff      	clr	tBCD2				;clear result (3 bytes)
000403 24ee      	clr	tBCD1		
000404 24dd      	clr	tBCD0		
000405 27ff      	clr	ZH					;clear ZH (not needed for AT90Sxx0x)
                 bBCDx_1:
000406 0f00      	lsl	fbinL				;shift input value
000407 1f11      	rol	fbinH				;through all bytes
000408 1cdd      	rol	tBCD0				;
000409 1cee      	rol	tBCD1
00040a 1cff      	rol	tBCD2
00040b 952a      	dec	cnt16a				;decrement loop counter
00040c f409      	brne bBCDx_2			;if counter not zero
00040d 9508      	ret						;   return
                 
                 bBCDx_2:
00040e e1e0      	ldi	r30,AtBCD2+1		;Z points to result MSB + 1
                 bBCDx_3:	
00040f 9132      	ld	tmp16a,-Z			;get (Z) with pre-decrement
000410 5f3d      	subi tmp16a,-$03		;add 0x03
000411 fd33      	sbrc tmp16a,3			;if bit 3 not clear
000412 8330      	st Z,tmp16a				;store back
000413 8130      	ld	tmp16a,Z			;get (Z)
000414 5d30      	subi tmp16a,-$30		;add 0x30
000415 fd37      	sbrc tmp16a,7			;if bit 7 not clear
000416 8330      	st	Z,tmp16a			;store back
000417 30ed      	cpi	ZL,AtBCD0			;done all three?
000418 f7b1      	brne bBCDx_3			;loop again if not
000419 cfec      	rjmp bBCDx_1	
                 
                 .undef	tBCD0				;BCD value digits 1 and 0
                 .undef	tBCD1				;BCD value digits 3 and 2
                 .undef	tBCD2				;BCD value digit 4
                 .undef	fbinL				;binary value Low byte
                 .undef	fbinH				;binary value High byte
                 .undef	cnt16a				;loop counter
                 .undef	tmp16a				;temporary value
                 
                 
                 
                 ;------------DELAY 10 MS--------------------------
                 ;This subroutine is placed here, if it was required during 
                 ; the lab. Its not called anywhere in the code. 
                 ;delays for 10ms 
                 ;r20 set to 100
                 ;r21 set to 33
                 ; combined delay will yield 9999 clock cycles
                 ;-------------------------------------------------
                 delay:
00041a 930f      	push r16
00041b 931f      	push r17
00041c e604      	ldi r16,100
                 	outer:
00041d e211      		ldi r17, 33
                 		inner:
00041e 951a      			dec r17
00041f f7f1      			brne inner
000420 950a      			dec r16
000421 f7d9      			brne outer
000422 911f      	pop r17
000423 910f      	pop r16
000424 9508      	ret
                 ;________________________________________________________________________


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega16" register use summary:
r0 :   0 r1 :   4 r2 :   6 r3 :   4 r4 :   6 r5 :   2 r6 :   6 r7 :   3 
r8 :   8 r9 :   9 r10:   7 r11:   0 r12:   0 r13:   5 r14:   5 r15:   2 
r16: 154 r17:  32 r18:  32 r19:  32 r20:   8 r21:  20 r22:   2 r23:  10 
r24:  12 r25:  27 r26:   7 r27:   2 r28:   3 r29:   3 r30:  37 r31:  36 
x  :   0 y  :   2 z  :  10 
Registers used: 31 out of 35 (88.6%)

"ATmega16" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   5 adiw  :   2 and   :   5 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   1 break :   0 breq  :  18 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  27 brpl  :   0 brsh  :   6 brtc  :   2 brts  :   3 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  11 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   7 cls   :   0 
clt   :   6 clv   :   0 clz   :   0 com   :   2 cp    :   8 cpc   :   0 
cpi   :  22 cpse  :   2 dec   :  21 eor   :   5 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  17 inc   :   5 jmp   :   4 
ld    :   5 ldd   :   0 ldi   : 168 lds   :   0 lpm   :   2 lsl   :   1 
lsr   :   0 mov   :  35 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :   4 or    :   0 ori   :   0 out   :  28 pop   :  26 
push  :  25 rcall : 136 ret   :  36 reti  :   3 rjmp  :  48 rol   :   6 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :  29 sbic  :   2 sbis  :  21 
sbiw  :   0 sbr   :   0 sbrc  :   2 sbrs  :   5 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   3 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   5 std   :   0 sts   :   0 
sub   :   1 subi  :   2 swap  :   7 tst   :   0 wdr   :   0 
Instructions used: 47 out of 113 (41.6%)

"ATmega16" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00084a   1572    534   2106   16384  12.9%
[.dseg] 0x000060 0x000090      0     48     48    1024   4.7%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
