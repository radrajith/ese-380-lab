
AVRASM ver. 2.1.52  C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\avm4\avm4\avm4.asm Fri Nov 21 11:42:38 2014

C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\avm4\avm4\avm4.asm(33): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.39.1005\avrassembler\Include\m16def.inc'
C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\avm4\avm4\avm4.asm(358): Including file 'C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\avm4\avm4\audio_playback_WTV20SD_beta.inc'
C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\avm4\avm4\avm4.asm(756): Including file 'C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\lab11\avm4\avm4\lcd_dog_asm_driver_m16A.inc'
                 
                 
                  * evm1c.asm
                  *
                 
                 
                  *
                  * Lab 10 - 
                  *
                  ; This program will continuously read the voltage values coming in through
                  ; port a pin 4, it will convert the analog signal to a digital signal. This 
                  ; all done by processor, only initialization of the adc converters are required. 
                  ; the converterted value 10 bit value is then sent to multiply with 50 and then 
                  ; divide subroutine to divide by 10. Both of these subrouitnes are provided by atmel 
                  ; the value obtained is then unpacked and displayed on the display. the process is '
                  ; repeated forever. The only thing different about this program compared to the first 
                  ; is that this will utilize an external interrupt to toggle between run and hold. 
                  ; when its in run mode the code will read the input analog voltage. when its in hold 
                  ; mode it will retain the value, and doesnt read again until the pbsw is pressed again.
                  ; registers used by code written by me
                  ; r1 - r5 to unpack the bits
                  ; r8 and r9 to copy the 10 bit value obtained after convertion
                  ; r16 for general purpose like initilization etc
                  ; r17 as a space counter used in the display subroutine
                  ; r28 initialized to 6. to keep r17 in check 
                  ; r27 as a toggle register. changes between 1 or 0 with press of center button 
                  ;r8 and r9 will be used to store the adc conversion values
                  *  Created: 10/29/2014 2:17:13 PM
                  *   Author: radra_000
                  
                  */
                  
                 .LIST 
                 
                 
                  ;********************************************************************
                 	 .cseg 
                 	 .org 0								;reset/restart code entry point <<<<<<<< 
000000 940c 0010 	 jmp reset	
                 	 
                 	 
                 	 
                 	 //when the counter is equal to 1s, the interrupt will be called
                 	 //0x0E is the adress for timer compare match B. 
                 	 //when the interrupt is called, it will jump to isr_tc0_display
                 	.org 0x002							;when external interrupt is pressed
000002 940c 00b7 	jmp menu							;its located on pd2
                 	 .org 0x0E
00000e 940c 00b0 	 jmp isr_tc0_display	
                 	// .org 0x01C							; timer intrrupt
                 	// jmp conv_check				;goes here when the time is up
                 
                 
                 reset:
000010 e50f      	ldi r16, low(ramend)
000011 bf0d      	out spl, r16
000012 e004      	ldi r16, high(ramend)
000013 bf0e      	out sph, r16						;initialize stack pointer
                 //button interrupt
000014 e003      	LDI r16,$03
000015 bf05      	out mcucr, r16
000016 e400      	ldi r16, 1 << INT0
000017 bf0b      	out gicr, r16
                 //input/output
000018 e000      	ldi r16, $00
000019 bb01      	out ddrd, r16						;set up the port b as inputs to read the pbsw values
00001a ef0f      	ldi r16, 0xff						; set portB = output.
00001b bb02      	out portd, r16
00001c eb0f      	ldi r16, 0b10111111	
00001d bb07          out ddrb, r16						; for lcd display
00001e 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
00001f 9ac0      	sbi portb, 0
000020 e001      	ldi r16, 1							; set DDRC for all in but PC0
000021 bb04      	out ddrc, r16
000022 9aa8      	sbi portc, 0						; turn off sounder
000023 e207      	ldi r16,0b00100111					; set up port a to 
000024 bb0a      	out ddra, r16						;read the frequency input on pa7 and output pulse on pa6
000025 9ad8      	sbi porta, 0
000026 9ad9      	sbi porta, 1
000027 9ada      	sbi porta, 2
000028 d2f1      	rcall init_lcd_dog
                 	//cbi porta, 5
000029 9478      	sei
00002a 94e8      	clt
00002b e000      	ldi r16, 0
00002c e050      	ldi r21, 0
                 
                 main:
00002d 3050      	cpi r21, 0
00002e f041      	breq run
00002f 3051      	cpi r21, 1
000030 f0a9      	breq hold
000031 3052      	cpi r21, 2
000032 f121      	breq capture1
000033 3053      	cpi r21, 3
000034 f119      	breq alarm
000035 3054      	cpi r21, 4
000036 f0f9      	breq freq_meter1
                 run:
000037 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
000038 9ac0      	sbi portb, 0
000039 d139      	rcall spi_setup					;sets up and gets the voltage from the max144
00003a d367      	rcall unpack					;conver the obtained values to numbers
00003b 2d2a      	mov r18, r10
00003c 2d36      	mov r19, r6
00003d 9522      	swap r18
00003e 2723      	eor r18, r19
00003f e439      	ldi r19, $49
000040 1723      	cp r18,r19
000041 f410      	brsh overflow_dis
000042 d20c      	rcall run_display					;display measured value. 
000043 cfe9      	rjmp main
                 
                 overflow_dis:
000044 d264      	rcall overflow
000045 cfe7      	rjmp main
                 hold:
000046 e000      	ldi r16, 0
000047 bf09      	out TIMSK, r16						;set up the timer interrupt
                 
000048 f3ee      	brts hold
000049 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
00004a 9ac0      	sbi portb, 0
00004b d127      	rcall spi_setup					;sets up and gets the voltage from the max144
00004c d355      	rcall unpack					;conver the obtained values to numbers
00004d 2d2a      	mov r18, r10
00004e 2d36      	mov r19, r6
00004f 9522      	swap r18
000050 2723      	eor r18, r19
000051 e439      	ldi r19, $49
000052 1723      	cp r18,r19
000053 f780      	brsh overflow_dis
000054 d218      	rcall hold_display					;display measured value. 
000055 cfd7      	rjmp main
                 freq_meter1:
000056 c038      	rjmp freq_meter
                 capture1:
000057 c01a      	rjmp capture
                 alarm:
000058 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
000059 9ac0      	sbi portb, 0
00005a d118      	rcall spi_setup					;sets up and gets the voltage from the max144
00005b d346      	rcall unpack					;conver the obtained values to numbers
00005c 2d2a      	mov r18, r10
00005d 2d36      	mov r19, r6
00005e 9522      	swap r18
00005f 2723      	eor r18, r19
000060 e439      	ldi r19, $49
000061 1723      	cp r18,r19
000062 f708      	brsh overflow_dis
000063 d227      	rcall alarm_display					;display measured value. 
000064 2722      	clr r18
000065 2d2a      	mov r18, r10
000066 2d37      	mov r19, r7
000067 9522      	swap r18
000068 2723      	eor r18, r19
000069 e330      	ldi r19, $30
00006a 0f37      	add r19, r23
00006b 1723      	cp r18,r19
00006c f408      	brsh alarmed
00006d cfbf      	rjmp main
                 alarmed:
00006e 98a8      	cbi portc, 0
00006f d366      	rcall delay
000070 9aa8      	sbi portc, 0
000071 cfbb      	rjmp main
                 
                 capture:
000072 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
000073 9ac0      	sbi portb, 0
000074 d0fe      	rcall spi_setup					;sets up and gets the voltage from the max144
000075 e000      	ldi r16, $00
000076 1509      	cp r16, r9
000077 f419      	brne next
000078 ef0a      	ldi r16, 250
000079 1508      	cp r16,r8
00007a f410      	brsh clear
                 next:
00007b f41e      	brtc run_once
00007c cfb0      	rjmp main
                 clear:
00007d 94e8      	clt
00007e cfae      	rjmp main
                 run_once:
00007f d322      	rcall unpack					;conver the obtained values to numbers
000080 2d2a      	mov r18, r10
000081 2d36      	mov r19, r6
000082 9522      	swap r18
000083 2723      	eor r18, r19
000084 e439      	ldi r19, $49
000085 1723      	cp r18,r19
000086 f540      	brsh overflow_dis1
000087 d18f      	rcall capture_display					;display measured value. 
000088 ff70      	sbrs r23, 0
000089 d0cb      	rcall audio
00008a 98a8      	cbi portc, 0
00008b d34a      	rcall delay
00008c 9aa8      	sbi portc, 0
00008d 9468      	set
00008e cf9e      	rjmp main						;calculation in the second run 
                 freq_meter:
00008f d239      	rcall freq_display					;after its unpacked, display 
000090 2488      	clr r8
000091 2499      	clr r9
000092 d0d7      	rcall start_tc1
000093 e003      	ldi r16, 0<<CS12|1<<CS11|1<<CS10	; load 64 PRESCaLE TCCR0 value. 
000094 bd0e      	out TCCR1B, r16						; and start timer
000095 d007      	rcall frequency_meter_3				; load the timer and count the frequency
000096 94e8      	clt									;clear the t flag
000097 1889      	sub r8, r9
000098 2d28      	mov r18, r8
000099 2d39      	mov r19, r9
00009a d307      	rcall unpack						;when timer is done, unpack the edge counts
00009b d22d      	rcall freq_display					;after its unpacked, display 
00009c cf90      	rjmp main							
                 
                 frequency_meter_3:
00009d e000      	ldi r16, $00
00009e 2e80      	mov r8, r16
00009f 2e90      	mov r9, r16
0000a0 b399      	in r25, pinA				;and positive edge counter
0000a1 7890      	andi r25,$80
                 	check_edge:		
0000a2 f04e      		brts finish2
0000a3 b309      		in r16, pina			;take in the current wave signal logic 
0000a4 7800      		andi r16,$80
0000a5 1709      		cp r16,r25			;and compare to previous logic recorded, 
0000a6 f3d9      		breq check_edge			;if it is the same then skip to tweak delay		
0000a7 2f90      		mov r25, r16
0000a8 9483      		inc r8				;and then increment the counter
0000a9 f7c1      		brne check_edge			;if it didnt over count then go to tweak delay
0000aa 9493      		inc r9				;if so then increment the second register
0000ab f7b6      		brtc check_edge
                 	finish2:
0000ac e000      		ldi r16, 0
0000ad bf09      		out TIMSK, r16						;set up the timer interrupt
0000ae 9508      		ret
                 
                 overflow_dis1:
0000af cf94      	rjmp overflow_dis
                 ;-----------------------------
                 ;when the interrupt is called it will jump to this subroutine
                 ;set the T flag, resets the timer, update the display 
                 
                 
                 isr_tc0_display:
                 ;codes will be added here after frequency subroutine is added. 
0000b0 930f      		push r16
0000b1 9468      		set									;set the tflag
0000b2 e000      		ldi r16, $00
0000b3 bd0d      		out TCNT1H, r16						; 
0000b4 bd0c      		out TCNT1L, r16						;reset the timer counter
0000b5 910f      		pop r16
0000b6 9518      		reti
                 
                 //menu interface
                 menu: 
0000b7 930f      	push r16
0000b8 3052      	cpi r21, 2
0000b9 f419      	brne check_hold
0000ba 9b84      	sbis pind, 4
0000bb c01f      	rjmp audio_offon
0000bc c004      	rjmp menu_loop
                 check_hold:
0000bd 3051      	cpi r21, 1
0000be f411      	brne menu_loop
0000bf 9b87      	sbis pind, 7
0000c0 c01d      	rjmp switch
                 menu_loop:
0000c1 b300      	in r16, pind
0000c2 9b85      	sbis pind, 5
0000c3 9553      	inc r21
0000c4 9b86      	sbis pind, 6
0000c5 955a      	dec r21
0000c6 ff07      	sbrs r16, 7
0000c7 c00d      	rjmp menu_check
                 wait_1:
0000c8 9b85      	sbis pind,5
0000c9 cffe      	rjmp wait_1
0000ca 9b86      	sbis pind,6
0000cb cffc      	rjmp wait_1
0000cc 3f5f      	cpi r21,$ff
0000cd f409      	brne check
0000ce e054      	ldi r21, 4
                 check:
0000cf 3055      	cpi r21,5
0000d0 f409      	brne good
0000d1 e050      	ldi r21,0
                 good:
0000d2 94e8      	clt
0000d3 d0b9      	rcall main_menu
0000d4 cfec      	rjmp menu_loop
                 menu_check:
0000d5 3053      	cpi r21,3
0000d6 f061      	breq alarm_set
                 menu_exit:
                 	//sbis pind,7
                 	//rjmp menu_exit
                 	//rcall capture_display
                 
0000d7 e400      	ldi r16, 1 << INTF0
0000d8 bf0a      	out gifr, r16
0000d9 910f      	pop r16
0000da 9518      	reti
                 audio_offon:
0000db 9570      	com r23
0000dc d13a      	rcall capture_display
0000dd cff9      	rjmp menu_exit 
                 
                 switch:
0000de f016      	brts clear1
0000df 9468      	set
0000e0 cff6      	rjmp menu_exit
                 clear1:
0000e1 94e8      	clt
0000e2 cff4      	rjmp menu_exit
                 
                 alarm_set:
0000e3 d10d      	rcall alarm_select
                 	//rjmp alarm_set
                 wait_press:
0000e4 9b83      	sbis pind, 3
0000e5 c007      	rjmp done_select
0000e6 9b84      	sbis pind, 4
0000e7 c005      	rjmp done_select
0000e8 9b85      	sbis pind, 5
0000e9 c003      	rjmp done_select
0000ea 9b86      	sbis pind, 6
0000eb c001      	rjmp done_select
0000ec cff7      	rjmp wait_press
                 done_select:
0000ed d2e8      	rcall delay
0000ee 9b83      	sbis pind, 3
0000ef e075      	ldi r23, 5
0000f0 9b84      	sbis pind, 4
0000f1 e078      	ldi r23, 8
0000f2 9b85      	sbis pind, 5
0000f3 e076      	ldi r23, 6
0000f4 9b86      	sbis pind, 6
0000f5 e077      	ldi r23, 7
                 wait_for_1:
0000f6 d2df      	rcall delay
0000f7 9b83      	sbis pind, 3
0000f8 cffd      	rjmp wait_for_1
0000f9 9b84      	sbis pind, 4
0000fa cffb      	rjmp wait_for_1
0000fb 9b85      	sbis pind, 5
0000fc cff9      	rjmp wait_for_1
0000fd 9b86      	sbis pind, 6
0000fe cff7      	rjmp wait_for_1
0000ff 94e8      	clt
000100 cfd6      	rjmp menu_exit
                 	//rjmp alarm_beep
                 	
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "audio_playback_WTV20SD_beta.inc" 
                 
                 ;;
                 ;;  -----------
                 ;;  modified mm/dd/yy  <initials>
                 ;;      <modification description text>
                 ;;  -----------
                 ;;  original release: 11/06/2014  FST  {BETA Version}
                 ;;      basic set of routines, including send_audio_r17r16 audio driver.
                 ;;--------------------------------------------------------------------------
                 
                 ;************************************************************************ 
                 ;  FILE NAME: audio_playback_WTV20SD_beta.inc    (Version 1b)
                 ;
                 ;  (ATmega16/ATmega16A  Initial Beta Version                                   
                 ;   
                 ;  This AVR-asm include module provides the asm-drivers to send
                 ;  audio playback message requests to the WTV20SD Audio Playback Module
                 ;
                 ;  This code is designed to be executed on an AVR ATMega micro-computer.
                 ;  
                 ;
                 ;************************************************************************
                 ;  This module contains all of the following procedures:
                 ;  ----------------------------------------------------
                 ;    1. Fixed DELAYS:
                 ;          audelay_30uS 
                 ;          audelay_300uS 
                 ;          audelay_1mS
                 ;          audelay_2mS
                 ;          audelay_40mS
                 ;    
                 ;    2. Audio request subroutine:
                 ;          send_audio_r17r16
                 ;
                 ;
                 
                 ;======== audmo DELAY ROUTINES =======================================	
                 
                 
                 
                 ;************************
                 ;NAME:        audelay_30uS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    SREG
                 ;CALLED BY:   
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             30 uS (assuming a 1 MHz clock).
                 ;********************************************************************
000101 0000      audelay_30uS: nop               ; fine tune delay
000102 0000           nop               ;
000103 938f           push  r24         ; save count reg
000104 e08f           ldi   r24, 0x0f   ; load delay count.
                 aud30_loop:
000105 958a           dec   r24         ; count down to
000106 f7f1           brne  aud30_loop  ; zero.
000107 918f           pop   r24         ; restore orig contents
000108 9508           ret
                 
                 
                 ;**************************
                 ;NAME:        audelay_300uS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R25, SREG
                 ;CALLED BY:   
                 ;DESCRIPTION: This procedure will generate a fixed delay of APPROX
                 ;             300 uS (assuming a 1 MHz clock).
                 ;********************************************************************
                 audelay_300uS:
000109 e09a          ldi   r25, 10        ; loop count = 10 decimal
                 dly_300_loop:
00010a 939f          push  r25 
00010b dff5          rcall audelay_30uS
00010c 919f          pop   r25
00010d 959a          dec   r25            ; count down to
00010e f7d9          brne  dly_300_loop   ; zero.
00010f 9508          ret
                 
                 
                 ;*************************************************************
                 ; audelay_1mS - Nested loop delay for creating a delay of 1 mS
                 ; inputs: none
                 ; outputs: none
                 ; alters: nothing
                 ;
                 ; equates for this delay routine
                 .equ outer_cnt11 = 0x18  ; *20* worked (loop ctr val)
                 .equ inner_cnt11 = 0x0d  ; inner loop ctr load value
                 ;
                 ;****************************************************
                 audelay_1mS:
000110 930f          push r16
000111 931f          push r17
000112 e108          ldi  r16,outer_cnt11   ;init outer loop counter value
                 dloop111:
000113 e01d          ldi  r17,inner_cnt11   ;init inner loop counter value
                 dloop222:
000114 951a          dec  r17               ; decr inner count and if
000115 f7f1          brne dloop222          ; 0, fall thru.
000116 950a          dec r16                ; decr outer count, and if
000117 f7d9          brne dloop111          ; 0, fall thru.
000118 911f          pop  r17
000119 910f          pop  r16
00011a 9508          ret       
                 
                 
                 
                 ;*************************************************************
                 ; audelay_2mS - Nested loop delay for creating a delay of 2 mS
                 ; inputs: none
                 ; outputs: none
                 ; alters: nothing
                 ;
                 ; equates for this delay routine
                 .equ outer_cnt2 = 0x33  ; outer loop counter load value
                 .equ inner_cnt2 = 0x0d  ; inner loop counter load value
                 ;
                 ;***********************************************
                 audelay_2mS:
00011b 930f          push r16
00011c 931f      push r17
00011d e303          ldi  r16,outer_cnt2   ;init outer loop counter value
                 dloop11:
00011e e01d          ldi  r17,inner_cnt2   ;init inner loop counter value
                 dloop22:
00011f 951a          dec  r17             ; decr inner count and if
000120 f7f1          brne dloop22          ; 0, fall thru.
000121 950a          dec r16              ; decr outer count, and if
000122 f7d9          brne dloop11          ; 0, fall thru.
000123 911f          pop  r17
000124 910f          pop  r16
000125 9508          ret       
                 
                 
                 ;*********************************************************************
                 ; audelay_10mS - Nested loop delay for creating a 10mS
                 ;                (Useful for software debouncing)
                 ;
                 ; inputs: none
                 ; outputs: none
                 ; alters: nothing
                 ;
                 ; Debouncing delay equate counts
                 .equ o_cnt = 0xf1  ; outer loop counter load value
                 .equ i_cnt = 0x0d  ; inner loop counter load value
                 ;
                 ;***********************************************
                 audelay_10mS:
000126 930f          push r16             ; save registers
000127 931f          push r17
000128 ef01          ldi  r16,o_cnt   ; init outer loop counter value
                 audloop1:
000129 e01d          ldi  r17,i_cnt   ; init inner loop counter value
                 audloop2:
00012a 951a          dec  r17             ; decr inner count and if
00012b f7f1          brne audloop2          ; 0, fall thru.
00012c 950a          dec r16              ; decr outer count, and if
00012d f7d9          brne audloop1          ; 0, fall thru.
00012e 911f          pop  r17             ; restore registers
00012f 910f          pop  r16
000130 9508          ret 
                 
                 
                 
                 ;************************
                 ;NAME:        audelay_300mS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22,R23, SREG
                 ;CALLED BY:   init_dsp, ????
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             300 mS.
                 ;********************************************************************
                 audelay_300mS:
000131 e19b           ldi  r25, 27      ; outer loop ctr : *26* was min that worked
                                        ; load count-down value for ~300mS
                 audelay_300ms_loop:
000132 939f           push  r25           ; save loop counter
000133 dff2           rcall audelay_10mS  ; do a 10 mS delay, 35 times
000134 919f           pop   r25           ; restore loop counter
000135 959a           dec   r25           ; dec and check for 0
000136 f7d9           brne  audelay_300ms_loop
000137 9508           ret
                 	 
                 
                 ;************************
                 ; NAME: send_audio_r17r16
                 ; DESC: Each call causes a 16 bit value to be transmitted to 
                 ;   the audio playback module. The 16-bit value can range 
                 ;   from 0x0000 to 0x01ff, providing for the playback of 
                 ;   up to 512 .AD4 audio message files (AMFs). 
                 ;
                 ;  Currently: AMFs 0x0000 to 0x0009 are the matching
                 ;     "number" audio files. So to output an audio "1", 
                 ;     you load r17r16 with 0x0001.  To output an audio "2",
                 ;     load r17:r16 withh 0x0002, and so on. See below for 
                 ;     a full list presently available, pre-recorded
                 ;     audio playback messages
                 ;
                 ; Interface signals:
                 ;    DATA   = PA0    Data out to audio module.
                 ;    DCLK   = PA1    Normally logic 1, Low for 2mS at start.
                 ;    RESET  = PA2    Pulsed low, for 5mS, high for 300 mS
                 ;                    before the clock goes low for 2mS.
                 ;    BUSY   = PA3    Compicated signal!! (300mS delay required
                 ;                    before testing this bit)
                 ;                    1=processing data (busy), 0=ready for data
                 ;
                 ; Assumes: r17:r16 = trigger data to be serially sent. Sound 
                 ;                    files available are as follows:
                 ;
                 ;    r17:r16 =  0x0000 = zero
                 ;            =  0x0001 = one
                 ;            =	0x0002 = two
                 ;                  ...
                 ;                  ...
                 ;            =  0x0009 = nine
                 ;            =  0x000a = 'point'
                 ;            =
                 ;-------------
                 ; Inputs: r17:r16, PA3=Busy status bit
                 ; Outputs: PA0=DATA; PA1=DCK; PA2=RESET (audio module)
                 ; Notes: TIMING FOR THIS MODULE IS CRITICAL & IT IS
                 ;        SUGGESTED THAT THE DELAY TIMES NOT BE ALTERED.
                 ;
                 send_audio_r17r16:
                 check_busy:
000138 99cb           sbic  PinA, 3           ; if BUSY = 1... Wait!
000139 cffe           rjmp  check_busy    ;
00013a dfeb           rcall audelay_10mS  ; **10mS**
                 check_busyy:
00013b 99cb           sbic  PinA, 3           ; if BUSY = 1... Wait!
00013c cffe           rjmp  check_busyy   ;
                 
                 reset_pulse:
00013d 98da           cbi  PortA, 2         ; take RESET of audmo low...
00013e dfd1           rcall audelay_1mS     ; **10mS** must be low for > 5 mS,
00013f 9ada           sbi  PortA, 2         ; take RESET back to '1'.
                 
                      ;audelay for 300mS before dclk goes low
000140 dff0           rcall audelay_300mS   ; REQ'D delay of 300mS
                 take_clk_low:
000141 98d9           cbi   PortA, 1        ; take DCLK low, and delay
000142 dfcd           rcall audelay_1mS     ; **1mS** 
                 
                      ;send ZEROs loop
000143 e120           ldi   r18, 0x010    ; load loop counter (16 clocks)
                 send_r17r16_loop:
000144 1f00           rol   r16           ; rotate and test next bit...
000145 1f11           rol   r17           ; (move bit into CY)
000146 f010           brcs  out_one       ; if cy set, brch to output a '1'
000147 98d8           cbi   PortA, 0      ; OK... data bit is '0'
000148 c001           rjmp  pulse_clk     ; jmp and gen clock pulse
                 out_one:
000149 9ad8           sbi   PortA, 0      ; data bit is '1'
                 pulse_clk:
00014a 98d9           cbi   PortA, 1      ; Take clk low, and
00014b dfc4           rcall audelay_1mS   ; delay for 1mS
00014c 9ad9           sbi   PortA, 1      ; set clock bit high
00014d dfc2           rcall audelay_1mS   ; delay for 2mS
00014e 952a      	 dec   r18           ; check loop counter &
00014f f7a1           brne  send_r17r16_loop  ; jump if NOT zero
                 
                 take_clk_data_high:
000150 9ad9           sbi   PortA, 1      ; Take clk high, and
000151 9ad8           sbi   PortA,0       ; take data high.
000152 dfd3           rcall audelay_10mS  ; delay, and both
000153 dfd2           rcall audelay_10mS  ; SEEM to be REQUIRED!
000154 9508           ret 
                 
                 
                 ;*** END OF AUDIO OUTOUT RELATED ROUTINES ***
                 ;==============================================
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;*********************audio********************************
                 ;puts the value in r16 and r17 and send it to the subroutine
                 ; to make the audio module read the voltage on the screen 
                 ;*******************************************************
                 audio:
000155 930f      	push r16
000156 931f      	push r17
000157 e010      	ldi r17, $00
000158 e000      	ldi r16, $00
000159 2d0a      	mov r16, r10						;send msb
00015a dfdd      	rcall send_audio_r17r16			;read the voltage, subrouitne
00015b e010      	ldi r17, $00
00015c e00a      	ldi r16, $0A					;send dot
00015d dfda      	rcall send_audio_r17r16			;read the voltage, subrouitne 
00015e e010      	ldi r17, $00
00015f 2d07      	mov r16, r7						;send 2nd number
000160 dfd7      	rcall send_audio_r17r16			;read the voltage, subrouitne
000161 e010      	ldi r17, $00
000162 2d06      	mov r16, r6						;send third number
000163 dfd4      	rcall send_audio_r17r16			;read the voltage, subrouitne
000164 e010      	ldi r17, $00
000165 2d05      	mov r16, r5						;send fourth number
000166 dfd1      	rcall send_audio_r17r16			;read the voltage, subrouitne
000167 911f      	pop r17
000168 910f      	pop r16
000169 9508      	ret
                 ;*********************TIMER INITIALIZATION*************************** 
                 ;_____________________________________________________________________
                 	
                 start_tc1:	
                 //intialization for the timer
                 /*	ldi r16, $00
                 	out TCNT1H, r16						; set up counter with 0's
                 	out TCNT1L, r16			*/		;
                 	;Init Timer/counter Interrupt MaSK (TIMSK) register to enable/set 
00016a e008      	ldi r16, 1<<OCIE1B							;load with bcd 1000, this will enable the 
                 										;"ocie1b" which is located in bit 4 of the register. 
                 										;refer to datasheet pg 115 for details
00016b bf09      	out TIMSK, r16						;set up the timer interrupt
                 
00016c e008      	ldi r16, 1<<OCF1B					;loading the timer interrupt flag register
00016d bf08      	out TIFR, r16						;
                 
                 
00016e e10f      	ldi r16, $1f						;load the counter with 15625
00016f bd09      	out OCR1BH, r16						; so that we will get 1s 
000170 e007      	ldi r16, $07
000171 bd08      	out OCR1BL, r16						;
                 	//sei									;enable global interrupts...
                 
                 
                 	;TCCR1B = FOC0 : WGM11 : COM11 : COM10 : WGM11 : CS12 : CS11 : CS10 
                 	; 0 0 0 0 0 0 1 1 
                 	; FOC Off; No WF Gen; COM=Nrml Port Op; Pre-scaler= 1/64 
                  
                 
000172 9508      	ret
                 	
                 ;*********************spi_setup*******************************
                 ; Get the voltage from max144, by reading the input values for 
                 ; 12 clock cycles. The registers used to store the 12 bits are 
                 ; r8 and r9 
                 
                 spi_setup:
                 
000173 e500      	ldi r16, (1<<spe)|(1<<mstr)
000174 b90d      	out SPCR, r16					;Enable SPI, Master, fck/4,
000175 b10e      	in r16, spsr
000176 b10f      	in r16, spdr 
000177 98c0      	cbi portb, 0
000178 9ac4      	sbi portb, 4
000179 d25c      	rcall delay
00017a ea0a      	ldi r16, $AA
00017b b90f      	out SPDR, r16					;set up dummy value in data register	
                 	wait_H:
00017c 9b77      		sbis spsr, spif
00017d cffe      		rjmp wait_H
00017e b09f      		in r9, spdr
00017f b90f      		out spdr, r16
                 	wait_L:
000180 9b77      		sbis spsr, spif
000181 cffe      		rjmp wait_L
000182 b08f      		in r8, spdr
000183 932f      		push r18
000184 e02f      		ldi r18, $0f
000185 2292      		and r9, r18						;delete first four bits
000186 912f      		pop r18
000187 9ab0      		sbi pinb,0
000188 9ab4      		sbi pinb, 4
000189 2d28      		mov r18, r8
00018a 2d39      		mov r19, r9
00018b 9508      	ret
                 
                 
                 
                 
                 ;**************************************************************************
                 ;---------------------------- SUBROUTINES ----------------------------
                 
                 ;*********************LCD DISPLAY CODE******************************
                 
                 ;---------------------------------------------------------
                 ;Code to load and display each line on the lcd 
                 ;r25 is used to load the value of the each digit to the pointer
                 ;line 2 refers to table, which containes numbers and depending 
                 ;on the frequncy, each number is picked and displayed 
                 ;---------------------------------------------------------
                 
                 display:
                    
00018c d1d0         rcall clr_dsp_buffs					; clear all three buffer lines
                    //brtc	run_display
                    //brts hold_display
                 
                 main_menu:
                    ;load 1st line of prompt message into dbuff1
00018d e0f3         ldi  ZH, high(line1_message1<<1)		;
00018e e6e4         ldi  ZL, low(line1_message1<<1)		;
00018f d1d5         rcall load_msg						; load message into buffer(s).
                 
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
000190 3050      cpi r21, 0
000191 f041      breq menu_run							;if r16 is 1 display run highlighted
000192 3051      cpi r21, 1
000193 f051      breq menu_hold							;display hold highlighted
000194 3052      cpi r21, 2
000195 f061      breq menu_capture						;display capture highlighted
000196 3053      cpi r21, 3
000197 f091      breq menu_alarm
000198 3054      cpi r21, 4
000199 f061      breq menu_freq
                 menu_run:
00019a e0f3         ldi ZH, high(line2_message_r<<1)		;
00019b e7e6         ldi ZL, low(line2_message_r<<1)		;load the table to stack
00019c d1c8         rcall load_msg
00019d c00f         rjmp thirdline
                 menu_hold:
00019e e0f3         ldi ZH, high(line2_message_h<<1)		;
00019f e8e8         ldi ZL, low(line2_message_h<<1)		;load the table to stack
0001a0 d1c4         rcall load_msg
0001a1 c00b         rjmp thirdline
                 menu_capture:
0001a2 e0f3         ldi ZH, high(line2_message_c<<1)		;
0001a3 e9ea         ldi ZL, low(line2_message_c<<1)		;load the table to stack
0001a4 d1c0         rcall load_msg
0001a5 c007         rjmp thirdline
                  menu_freq:
0001a6 e0f3         ldi ZH, high(line2_message_t<<1)		;
0001a7 ebee         ldi ZL, low(line2_message_t<<1)		;load the table to stack
0001a8 d1bc         rcall load_msg
0001a9 c003         rjmp thirdline
                 menu_alarm:
0001aa e0f3         ldi ZH, high(line2_message_a<<1)		;
0001ab eaec         ldi ZL, low(line2_message_a<<1)		;load the table to stack
0001ac d1b8         rcall load_msg
                 thirdline:
                    //rcall load_msg						;load the frequency number into the buffer
                 
                    ;load 3rd line of prompt message into dbuff3
0001ad e0f3         ldi  ZH, high(line3_message1<<1)		;
0001ae ede0         ldi  ZL, low(line3_message1<<1)		;
0001af d1b5         rcall load_msg						; load message into buffer(s).
0001b0 d187         rcall update_lcd_dog
                 
0001b1 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
0001b2 2a01
0001b3 2a2a
0001b4 614d
0001b5 6e69
0001b6 4d20
0001b7 6e65
0001b8 2a75
0001b9 2a2a
0001ba 002a      line1_message1:	.db 1, "***Main Menu****", 0  ; test string for line #1.
0001bb 4604
0001bc 4552
0001bd 2051
0001be 2020
0001bf 5552
0001c0 204e
0001c1 4820
0001c2 4c4f
0001c3 0044      line2_message_r:.db 4,"FREQ   RUN  HOLD",0
0001c4 5204
0001c5 4e55
0001c6 2020
0001c7 2020
0001c8 4f48
0001c9 444c
0001ca 2020
0001cb 4143
0001cc 0050      line2_message_h:.db 4,"RUN    HOLD  CAP",0
0001cd 4804
0001ce 4c4f
0001cf 2044
0001d0 2020
0001d1 4143
0001d2 2050
0001d3 2020
0001d4 4c41
0001d5 004d      line2_message_c:.db 4,"HOLD   CAP   ALM",0
0001d6 4304
0001d7 5041
0001d8 2020
0001d9 2020
0001da 4c41
0001db 204d
0001dc 4620
0001dd 4552
0001de 0051      line2_message_a:.db 4,"CAP    ALM  FREQ",0
0001df 4104
0001e0 4d4c
0001e1 2020
0001e2 2020
0001e3 5246
0001e4 5145
0001e5 2020
0001e6 5552
0001e7 004e      line2_message_t:.db 4,"ALM    FREQ  RUN",0
0001e8 2003
0001e9 2020
0001ea 2020
0001eb 2020
0001ec 5e5e
0001ed 5e5e
0001ee 2020
0001ef 2020
0001f0 0020      line3_message1:	.db 3,"       ^^^^     ", 0  ; test string for line #3.
                 ;*************************************************************************************
                 alarm_select:
                 
                    ;load 1st line of prompt message into dbuff1
0001f1 e0f3         ldi  ZH, high(line1_message7<<1)		;
0001f2 efe8         ldi  ZL, low(line1_message7<<1)		;
0001f3 d171         rcall load_msg						; load message into buffer(s).
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
                 
                 
0001f4 e0f4         ldi ZH, high(line2_message_7<<1)		;
0001f5 e0ea         ldi ZL, low(line2_message_7<<1)		;load the table to stack
0001f6 d16e         rcall load_msg
                 
                    //rcall load_msg						;load the frequency number into the buffer
                 
                    ;load 3rd line of prompt message into dbuff3
0001f7 e0f4         ldi  ZH, high(line3_message7<<1)		;
0001f8 e1ec         ldi  ZL, low(line3_message7<<1)		;
0001f9 d16b         rcall load_msg						; load message into buffer(s).
0001fa d13d         rcall update_lcd_dog
0001fb 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
0001fc 2001
0001fd 2020
0001fe 2020
0001ff 2020
000200 2e33
000201 2035
000202 2020
000203 2020
000204 0020      line1_message7:	.db 1,"       3.5      ", 0  ; test string for line #1.
000205 3304
000206 362e
000207 2020
000208 2020
000209 2020
00020a 2020
00020b 2020
00020c 2e33
00020d 0037      line2_message_7:.db 4,"3.6          3.7",0
00020e 2003
00020f 2020
000210 2020
000211 2020
000212 2e33
000213 2038
000214 2020
000215 2020
000216 0020      line3_message7:	.db 3,"       3.8      ", 0  ; test string for line #3.
                 
                  capture_display:
                 
                  // rcall spi_setup
                    ;load 1st line of prompt message into dbuff1
000217 e0f4         ldi  ZH, high(line1_message<<1)		;
000218 e4e8         ldi  ZL, low(line1_message<<1)		;
000219 d14b         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
00021a e0f4         ldi ZH, high(line2_message<<1)		;
00021b e5ea         ldi ZL, low(line2_message<<1)		;load the table to stack
00021c d148         rcall load_msg			.			;load the frequency number into the buffer
00021d ff71         sbrs r23, 1
00021e c018         rjmp linechange
                 
                    ;load 3rd line of prompt message into dbuff3
00021f e0f4         ldi  ZH, high(line3_message<<1)		;
000220 e5ec         ldi  ZL, low(line3_message<<1)		;
000221 d143         rcall load_msg						; load message into buffer(s).
000222 d115         rcall update_lcd_dog
                 
000223 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
000224 2a01
000225 2a2a
000226 2a2a
000227 6f56
000228 746c
000229 6761
00022a 2a65
00022b 2a2a
00022c 002a      line1_message:	.db 1, "*****Voltage****", 0  ; test string for line #1.
00022d 0002      line2_message:	.db 2,"",0
00022e 4303
00022f 5041
000230 5554
000231 4552
000232 2020
000233 2020
000234 2020
000235 666f
000236 0066      line3_message:	.db 3, "CAPTURE      off", 0  ; test string for line #3.
                 
                 
                  linechange: 
                    ;load 3rd line of prompt message into dbuff3
000237 e0f4         ldi  ZH, high(line3_message0<<1)		;
000238 e8ec         ldi  ZL, low(line3_message0<<1)		;
000239 d12b         rcall load_msg						; load message into buffer(s).
00023a d0fd         rcall update_lcd_dog
                 
00023b 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
00023c 2a01
00023d 2a2a
00023e 2a2a
00023f 6f56
000240 746c
000241 6761
000242 2a65
000243 2a2a
000244 002a      line1_message0:	.db 1, "*****Voltage****", 0  ; test string for line #1.
000245 0002      line2_message0:	.db 2,"",0
000246 4303
000247 7061
000248 7574
000249 6572
00024a 2020
00024b 2020
00024c 2020
00024d 6f20
00024e 006e      line3_message0:	.db 3, "Capture       on", 0  ; test string for line #3.
                 
                 ;**************************************************************************************
                   run_display:
                 
                    ;load 1st line of prompt message into dbuff1
00024f e0f4         ldi  ZH, high(line1_message2<<1)		;
000250 ebe4         ldi  ZL, low(line1_message2<<1)		;
000251 d113         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
000252 e0f4         ldi ZH, high(line2_message2<<1)		;
000253 ece6         ldi ZL, low(line2_message2<<1)		;load the table to stack
000254 d110         rcall load_msg						;load the frequency number into the buffer
                    
                 
                    ;load 3rd line of prompt message into dbuff3
000255 e0f4         ldi  ZH, high(line3_message2<<1)		;
000256 ece8         ldi  ZL, low(line3_message2<<1)		;
000257 d10d         rcall load_msg						; load message into buffer(s).
000258 d0df         rcall update_lcd_dog
000259 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
00025a 2a01
00025b 2a2a
00025c 2a2a
00025d 6f56
00025e 746c
00025f 6761
000260 2a65
000261 2a2a
000262 002a      line1_message2:	.db 1, "*****Voltage****", 0  ; test string for line #1.
000263 0002      line2_message2:	.db 2,"",0
000264 5203
000265 4e55
000266 2020
000267 2020
000268 2020
000269 2020
00026a 4d20
00026b 444f
00026c 0045      line3_message2:	.db 3, "RUN         MODE", 0  ; test string for line #3.
                 
                 ;***************************************************************************************
                 ;**************************************************************************************
                   hold_display:
                 
                    ;load 1st line of prompt message into dbuff1
00026d e0f4         ldi  ZH, high(line1_message3<<1)		;
00026e efe0         ldi  ZL, low(line1_message3<<1)		;
00026f d0f5         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
000270 e0f5         ldi ZH, high(line2_message3<<1)		;
000271 e0e2         ldi ZL, low(line2_message3<<1)		;load the table to stack
000272 d0f2         rcall load_msg						;load the frequency number into the buffer
                    
                 
                    ;load 3rd line of prompt message into dbuff3
000273 e0f5         ldi  ZH, high(line3_message3<<1)		;
000274 e0e4         ldi  ZL, low(line3_message3<<1)		;
000275 d0ef         rcall load_msg						; load message into buffer(s).
000276 d0c1         rcall update_lcd_dog
000277 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
000278 2a01
000279 2a2a
00027a 2a2a
00027b 6f56
00027c 746c
00027d 6761
00027e 2a65
00027f 2a2a
000280 002a      line1_message3:	.db 1, "*****Voltage****", 0  ; test string for line #1.
000281 0002      line2_message3:	.db 2,"",0
000282 4803
000283 4c4f
000284 2044
000285 2020
000286 2020
000287 2020
000288 4d20
000289 444f
00028a 0045      line3_message3:	.db 3, "HOLD        MODE", 0  ; test string for line #3.
                 ;*****************************************************************************
                 alarm_display:
                 
                 
                    ;load 1st line of prompt message into dbuff1
00028b e0f5         ldi  ZH, high(line1_message6<<1)		;
00028c e2ec         ldi  ZL, low(line1_message6<<1)		;
00028d d0d7         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
00028e e0f5         ldi ZH, high(line2_message6<<1)		;
00028f e3ee         ldi ZL, low(line2_message6<<1)		;load the table to stack
000290 d0d4         rcall load_msg			.			;load the frequency number into the buffer
                    
                 
                    ;load 3rd line of prompt message into dbuff3
000291 e0f5         ldi  ZH, high(line3_message6<<1)		;
000292 e4e0         ldi  ZL, low(line3_message6<<1)		;
000293 d0d1         rcall load_msg						; load message into buffer(s).
000294 d0a3         rcall update_lcd_dog
                 
000295 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
000296 2a01
000297 2a2a
000298 2a2a
000299 6f56
00029a 746c
00029b 6761
00029c 2a65
00029d 2a2a
00029e 002a      line1_message6:	.db 1, "*****Voltage****", 0  ; test string for line #1.
00029f 0002      line2_message6:	.db 2,"",0
0002a0 4103
0002a1 414c
0002a2 4d52
0002a3 2020
0002a4 2020
0002a5 2020
0002a6 4d20
0002a7 444f
0002a8 0045      line3_message6:	.db 3, "ALARM       MODE", 0  ; test string for line #3.
                 ;*****************************************************************************
                  overflow: 
                    ;load 3rd line of prompt message into dbuff3
0002a9 e0f5         ldi  ZH, high(line2_message5<<1)		;
0002aa e6ee         ldi  ZL, low(line2_message5<<1)		;
0002ab d0b9         rcall load_msg						; load message into buffer(s).
0002ac d08b         rcall update_lcd_dog
                 
0002ad 9508         ret
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
0002ae 2a01
0002af 2a2a
0002b0 2a2a
0002b1 6f56
0002b2 746c
0002b3 6761
0002b4 2a65
0002b5 2a2a
0002b6 002a      line1_message5:	.db 1, "*****Voltage****", 0  ; test string for line #1.
0002b7 2004
0002b8 766f
0002b9 7265
0002ba 7420
0002bb 6568
0002bc 6c20
0002bd 6d69
0002be 7469
0002bf 0020      line2_message5:	.db 4, " over the limit ",0
0002c0 2003
0002c1 2020
0002c2 2020
0002c3 2020
0002c4 2020
0002c5 2020
0002c6 2020
0002c7 2020
0002c8 0020      line3_message5:	.db 3, "                ", 0  ; test string for line #3.
                 ;********************************************************************************
                 freq_display:
                 
                    ;load 1st line of prompt message into dbuff1
0002c9 e0f5         ldi  ZH, high(line1_message8<<1)		;
0002ca eae8         ldi  ZL, low(line1_message8<<1)		;
0002cb d099         rcall load_msg						; load message into buffer(s).
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
0002cc e0f5         ldi ZH, high(line2_message8<<1)		;
0002cd ebea         ldi ZL, low(line2_message8<<1)		;load the table to stack
0002ce d096         rcall load_msg						;load the frequency number into the buffer
                    
                    ;load 3rd line of prompt message into dbuff3
0002cf e0f5         ldi  ZH, high(line3_message8<<1)		;
0002d0 ebec         ldi  ZL, low(line3_message8<<1)		;
0002d1 d093         rcall load_msg						; load message into buffer(s).
0002d2 d065         rcall update_lcd_dog
0002d3 9508         ret
                 
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
0002d4 2a01
0002d5 2a2a
0002d6 5246
0002d7 5145
0002d8 4555
0002d9 434e
0002da 2a59
0002db 2a2a
0002dc 002a      line1_message8:	.db 1, "***FREQUENCY****", 0  ; test string for line #1.
0002dd 0005      line2_message8:	.db 5,"",0
0002de 4b03
0002df 5a48
0002e0 2020
0002e1 2020
0002e2 2020
0002e3 3020
0002e4 352e
0002e5 4553
0002e6 0043      line3_message8:	.db 3, "KHZ       0.5SEC", 0  ; test string for line #3.
                 ;*******************************************************************************************
                 
                 ;====================================
                 .include "lcd_dog_asm_driver_m16A.inc"  ; LCD DOG init/update procedures.
                 
                 ;modified 11/26/12 KLS
                 ; lcd_spi_transmit_data and lcd_spi_transmit_CMD handling of SPIF flag
                 ;
                 ;modifued 07/21/14 FST
                 ; added BLOCK comments for adjusting power_ctrl & contrast_set parameters
                 ;
                 
                 
                 ;************************************************************************ 
                 ;   ATMega16A  2015 Version                           PRINT IN LANDSCAPE                     
                 ;   
                 ;   This AVR-asm code module is usable as an include file for assembly
                 ;   language and or mixed asm/C application programs. The code is freely 
                 ;   usable by any University of Stonybrook undergraduate students for any
                 ;   and all not-for-profit system designs and or implementations.
                 ;
                 ;   This code is designed to be executed on an AVR ATMega micro-computer.
                 ;   And may be readily adapted for compatibility with IAR/AVR compilers. 
                 ;   See the IAR assembler reference guide for more information by 
                 ;   clicking 'Help > AVR Assembly Reference Guide" on the above menus.
                 ;
                 ;
                 ;************************************************************************
                 ;
                 ;   This module contains procedures to initialize and update
                 ;   DOG text based LCD display modules, including the EA DOG163M LCD
                 ;   modules configured with three (3) 16 charactors display lines.
                 ;
                 ;   The display module hardware interface uses a 1-direction, write only
                 ;   SPI interface. (See below for more information.)
                 ;
                 ;   The display module software interface uses three (3) 16-byte
                 ;   data (RAM) based display buffers - One for each line of the display.
                 ;   (See below for more information.)
                 ;
                 ;*********************************************************************
                 ;
                 ;   *** Port B Interface Definitions:
                 ;
                 ;  Port B             PB7   PB6   PB5   PB4   PB3   PB2   PB1   PB0
                 ;  Port B alt names   SCK   MISO  MOSI  /SS   /RS    -     -     -
                 ;  LCD Mod Signal     D6     -     D7   /CSB   -     -     -     -
                 ;  LCD Mod Pin #      29     -     28    38    -     -     -     -
                 ;
                 ;  Notes: RS ==>  0 = command regs, 1 = data regs
                 ;         /SS = active low SPI select signal
                 ;
                 ;******************
                 
                 
                 ;***  DATA Segment  **************************************************   
                 .DSEG
000060           dsp_buff_1:   .byte 16
000070           dsp_buff_2:   .byte 16
000080           dsp_buff_3:   .byte 16
                 
                 
                 
                 
                 ;***  CODE Segment Subroutines  ************************************
                 .CSEG
                 
                 
                 
                 ;************************
                 ;NAME:        delay_30uS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R24, SREG
                 ;CALLED BY:   init_dsp
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             30 uS (assuming a 1 MHz clock).
                 ;********************************************************************
0002e7 0000      delay_30uS:   nop     ; fine tune delay
0002e8 0000                    nop
0002e9 938f                    push  r24
0002ea e08f                    ldi   r24, 0x0f  ; load delay count.
0002eb 958a      d30_loop:     dec   r24        ; count down to
0002ec f7f1                    brne  d30_loop   ; zero.
0002ed 918f                    pop   r24
0002ee 9508                    ret
                 
                 
                 
                 ;*********************
                 ;NAME:        v_delay
                 ;ASSUMES:     R22, R23 = initial count values defining how many
                 ;             30uS delays will be called. This procedure can generate
                 ;             short delays (r23 = small #) or much longer delays (where
                 ;             R23 value is large).
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22, R23, SREG
                 ;CALLED BY:   init_dsp, plus...
                 ;DESCRIPTION: This procedure will generate a variable delay for a fixed
                 ;             period of time based the values pasted in R24 and R25.
                 ;
                 ;Sample Delays:
                 ;
                 ;             R22  R23  DelayTime
                 ;             ---  ---  ---------
                 ;              1    1   ~65.5 uS
                 ;              0    1   ~14.2 mS
                 ;              0    9   ~130 mS
                 ;**********************************************************************
0002ef dff7      v_delay:      rcall delay_30uS ; delay for ~30uS
0002f0 956a                    dec   r22      ; decrement inner loop value, and
0002f1 f7e9                    brne  v_delay  ; loop until zero.
0002f2 957a                    dec   r23      ; decr outer loop count, and loop back
0002f3 f7d9                    brne  v_delay  ; to inner loop delay until r23 zero.
0002f4 9508                    ret
                 
                 
                 
                 
                 ;***********************
                 ;NAME:        delay_40mS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22,R23, SREG
                 ;CALLED BY:   init_dsp, ????
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             40 mS.
                 ;********************************************************************
0002f5 e060      delay_40mS:   ldi   r22,0        ; load inner loop var
0002f6 e074                    ldi   r23,4        ; load outer loop var
0002f7 dff7                    rcall  v_delay     ; delay
0002f8 9508                    ret
                 
                 
                 
                 
                 ;************************
                 ;NAME:       init_spi_lcd
                 ;ASSUMES:    IMPORTANT: PortB set as output (during program init)
                 ;RETURNS:    nothing
                 ;MODIFIES:   DDRB, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: init SPI port for command and data writes to LCD via SPI
                 ;********************************************************************
                 init_spi_lcd:
0002f9 930f            push r16
0002fa e50c            ldi r16,(1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA)
0002fb b90d            out SPCR,r16   ; Enable SPI, Master, fck/4, 
                       
                       ;kill any spurious data...
0002fc b10e            in r16, SPSR   ; clear SPIF bit in SPSR
0002fd b10f            in r16, SPDR   ;
0002fe 910f            pop r16        ; restore r16 value...
0002ff 9508            ret
                 
                 
                 
                 ;********************************
                 ;NAME:       lcd_spi_transmit_CMD
                 ;ASSUMES:    r16 = byte for LCD.
                 ;            SPI port is configured.
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, PortB, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: outputs a byte passed in r16 via SPI port. Waits for data
                 ;            to be written by spi port before continuing.
                 ;*********************************************************************
                 lcd_spi_transmit_CMD:
000300 930f           push r16          ; save command, need r16.
000301 98c3           cbi   portB, 3    ; clr PB1 = RS = 0 = command.
000302 98c4           cbi   portB, 4    ; clr PB2 = /SS = selected.
000303 b10e              in r16, SPSR   ; clear SPIF bit in SPSR.
000304 b10f              in r16, SPDR   ;
000305 910f           pop r16           ; restore command
000306 b90f           out SPDR,r16      ; write data to SPI port.
                 
                 
                      ;Wait for transmission complete
                 wait_transmit:
000307 b10e           in r16, SPSR     ; read status reg
000308 ff07           sbrs r16, SPIF   ; if bit 7  = 0 wait
000309 cffd           rjmp wait_transmit
00030a b10f      	 in r16, SPDR		;added by Ken to clear SPIF
00030b 9ac4           sbi   portB, 4   ; set PB2 = /SS = deselected
00030c 9508           ret
                 
                 
                 
                 
                 ;*********************************
                 ;NAME:       lcd_spi_transmit_DATA
                 ;ASSUMES:    r16 = byte to transmit to LCD.
                 ;            SPI port is configured.
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: outputs a byte passed in r16 via SPI port. Waits for
                 ;            data to be written by spi port before continuing.
                 ;*****************************************************************
                 lcd_spi_transmit_DATA:
00030d 930f           push r16          ; save command, need r16.
00030e 9ac3           sbi   portB, 3    ; clr PB1 = RS = 1 = data.
00030f 98c4           cbi   portB, 4    ; clr PB2 = /SS = selected.
000310 b10e              in r16, SPSR   ; clear SPIF bit in SPSR.
000311 b10f              in r16, SPDR   ;
000312 910f           pop r16           ; restore command.
000313 b90f           out SPDR,r16      ; write data to SPI port.
                 
                 
                      ;Wait for transmission complete
                 wait_transmit1:
000314 b10e           in r16, SPSR     ; read status reg
000315 ff07           sbrs r16, SPIF   ; if bit 7  = 0 wait
000316 cffd           rjmp wait_transmit1
000317 b10f      	 in r16, SPDR		;clear SPIF (because it follows in r16,SPSR)
000318 9ac4           sbi   portB, 4   ; set PB2 = /SS = deselected
000319 9508           ret
                 
                 
                 
                 ;************************
                 ;NAME:       init_lcd_dog
                 ;ASSUMES:    nothing
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, R17
                 ;CALLED BY:  main application
                 ;DESCRITION: inits DOG module LCD display for SPI (serial) operation.
                 ;NOTE:  Can be used as is with MCU clock speeds of 4MHz or less.
                 ;********************************************************************
                 ; public __version_1 void init_dsp(void)
                 init_lcd_dog:
00031a dfde             rcall init_spi_lcd   ; init SPI port for DOG LCD.
                 
                 
                 start_dly_40ms:
00031b dfd9             rcall  delay_40mS    ; startup delay.
                 
                 
                 func_set1:
00031c e309             ldi    r16,0x39      ; send fuction set #1
00031d dfe2             rcall  lcd_spi_transmit_CMD   ;
00031e dfc8             rcall  delay_30uS    ; delay for command to be processed
                 
                 
                 func_set2:
00031f e309             ldi    r16,0x39      ; send fuction set #2
000320 dfdf             rcall  lcd_spi_transmit_CMD
000321 dfc5             rcall  delay_30uS    ; delay for command to be processed
                 
                 
                 bias_set:
000322 e10e             ldi    r16,0x1E      ; set bias value.
000323 dfdc             rcall  lcd_spi_transmit_CMD
000324 dfc2             rcall  delay_30uS    ;
                 
                 
                                                    ; =============================================
                                                    ; === CALIBRATION PARAMETER - USER ADJUSTABLE
                 power_ctrl:                        ; === (CAUTION... VERY DELICATE ADJUSTMENT)
000325 e500             ldi    r16,0x50             ; === 5V ~= 0x50 nominal;      Adjust by 1 ONLY
000326 dfd9             rcall  lcd_spi_transmit_CMD ; === 3.3V ~= 0x55 nominal     and think hex!
000327 dfbf             rcall  delay_30uS           ;   Hex = 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f
                                                    ; ==========================================
                 
                 follower_ctrl:
000328 e60c             ldi    r16,0x6C      ; follower mode on... 
000329 dfd6             rcall  lcd_spi_transmit_CMD
00032a dfca             rcall  delay_40mS    ;
                                                    ; ============================================
                                                    ; === CALIBRATION PARAMETER - USER ADJUSTABLE
                 contrast_set:                      ; === LCD CONTRAST SETTING ADJUSTMENT
00032b e707             ldi    r16,0x77             ; === 
00032c dfd3             rcall  lcd_spi_transmit_CMD ; === Delicate: increases for 3.3V vs 5V
00032d dfb9             rcall  delay_30uS           ; ========================================= 
                 
                 display_on:
00032e e00c             ldi    r16,0x0c      ; display on, cursor off, blink off
00032f dfd0             rcall  lcd_spi_transmit_CMD
000330 dfb6             rcall  delay_30uS    ; 
                 
                 
                 clr_display:
000331 e001             ldi    r16,0x01      ; clear display, cursor home
000332 dfcd             rcall  lcd_spi_transmit_CMD
                 
                 
000333 dfb3             rcall  delay_30uS    ;
                 
                 
                 entry_mode:
000334 e006             ldi    r16,0x06      ; clear display, cursor home
000335 dfca             rcall  lcd_spi_transmit_CMD;
000336 dfb0             rcall  delay_30uS    ;
000337 9508             ret
                 
                 
                 
                 
                 ;**************************
                 ;NAME:       update_lcd_dog
                 ;ASSUMES:    display buffers loaded with display data
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16,R20,R30,R31,SREG
                 ;
                 ;DESCRITION: Updates the LCD display lines 1, 2, and 3, using the
                 ;  contents of dsp_buff_1, dsp_buff_2, and dsp_buff_3, respectively.
                 ;*******************************************************************
                 ; public __version_1 void update_dsp_dog (void)
                 update_lcd_dog:
000338 dfc0             rcall init_spi_lcd    ; init SPI port for LCD.
000339 e140             ldi   r20,16          ; init 'chars per line' counter.
00033a 934f             push  r20             ; save for later used.
                 
                 
                        ;send line 1 to the LCD module.
                 wr_line1:     
00033b e0f0             ldi   ZH, high (dsp_buff_1)  ; init ptr to line 1 display buffer.
00033c e6e0             ldi   ZL, low (dsp_buff_1)   ;
                 snd_ddram_addr:
00033d e800             ldi   r16,0x80             ; init DDRAM addr-ctr 
00033e dfc1             rcall lcd_spi_transmit_CMD ; 
00033f dfa7             rcall delay_30uS
                 snd_buff_1:
000340 9101             ld    r16, Z+
000341 dfcb             rcall lcd_spi_transmit_DATA
000342 dfa4             rcall delay_30uS
000343 954a             dec   r20
000344 f7d9             brne  snd_buff_1
                 
                 
                        ;send line 2 to the LCD module.
                 init_for_buff_2:
000345 914f             pop   r20     ; reload r20 = chars per line counter
000346 934f             push  r20     ; save for line 3
                 wr_line2:
000347 e0f0             ldi   ZH, high (dsp_buff_2)  ; init ptr to line 2 display buffer.
000348 e7e0             ldi   ZL, low (dsp_buff_2)
                 snd_ddram_addr2:
000349 e900             ldi   r16,0x90               ; init DDRAM addr-ctr 
00034a dfb5             rcall lcd_spi_transmit_CMD           ;  
00034b df9b             rcall delay_30uS
                 snd_buff_2:
00034c 9101             ld    r16, Z+
00034d dfbf             rcall lcd_spi_transmit_DATA
00034e df98             rcall delay_30uS
00034f 954a             dec   r20
000350 f7d9             brne  snd_buff_2
                 
                 
                        ;send line 3 to the LCD module.
                 init_for_buff_3:
000351 914f             pop   r20     ; reload r20 = chars per line counter
                 wr_line3:
000352 e0f0             ldi   ZH, high (dsp_buff_3)  ; init ptr to line 2 display buffer.
000353 e8e0             ldi   ZL, low (dsp_buff_3)
                 snd_ddram_addr3:
000354 ea00             ldi   r16,0xA0               ; init DDRAM addr-ctr 
000355 dfaa             rcall lcd_spi_transmit_CMD           ;  
000356 df90             rcall delay_30uS
                 
                 
                 snd_buff_3:
000357 9101             ld    r16, Z+
000358 dfb4             rcall lcd_spi_transmit_DATA
000359 df8d             rcall delay_30uS
00035a 954a             dec   r20
00035b f7d9             brne  snd_buff_3
00035c 9508             ret
                 
                 
                 ;******* End Of LCD DOG Include Module *********************************
                 ;====================================
                 
                 ;************************
                 ;NAME:      clr_dsp_buffs
                 ;FUNCTION:  Initializes dsp_buffers 1, 2, and 3 with blanks (0x20)
                 ;ASSUMES:   Three CONTIGUOUS 16-byte dram based buffers named
                 ;           dsp_buff_1, dsp_buff_2, dsp_buff_3.
                 ;RETURNS:   nothing.
                 ;MODIFIES:  r25,r26, Z-ptr
                 ;CALLS:     none
                 ;CALLED BY: main application and diagnostics
                 ;********************************************************************
                 clr_dsp_buffs:
00035d e390           ldi R25, 48						; load total length of both buffer.
00035e e2a0           ldi R26, ' '						; load blank/space into R26.
00035f e0f0           ldi ZH, high (dsp_buff_1)			; Load ZH and ZL as a pointer to 1st
000360 e6e0           ldi ZL, low (dsp_buff_1)			; byte of buffer for line 1.
                    
                     ;set DDRAM address to 1st position of first line.
                 store_bytes:
000361 93a1           st  Z+, R26						; store ' ' into 1st/next buffer byte and
                 										; auto inc ptr to next location.
000362 959a           dec  R25							; 
000363 f7e9           brne store_bytes					; cont until r25=0, all bytes written.
000364 9508           ret
                 
                 
                 ;*******************
                 ;NAME:      load_msg
                 ;FUNCTION:  Loads a predefined string msg into a specified diplay
                 ;           buffer.
                 ;ASSUMES:   Z = offset of message to be loaded. Msg format is 
                 ;           defined below.
                 ;RETURNS:   nothing.
                 ;MODIFIES:  r16, Y, Z
                 ;CALLS:     nothing
                 ;CALLED BY:  
                 ;********************************************************************
                 ; Message structure:
                 ;   label:  .db <buff num>, <text string/message>, <end of string>
                 ;
                 ; Message examples (also see Messages at the end of this file/module):
                 ;   msg_1: .db 1,"First Message ", 0   ; loads msg into buff 1, eom=0
                 ;   msg_2: .db 1,"Another message ", 0 ; loads msg into buff 1, eom=0
                 ;
                 ; Notes: 
                 ;   a) The 1st number indicates which buffer to load (either 1, 2, or 3).
                 ;   b) The last number (zero) is an 'end of string' indicator.
                 ;   c) Y = ptr to disp_buffer
                 ;      Z = ptr to message (passed to subroutine)
                 ;********************************************************************
                 load_msg:
000365 93af      	 push r26
000366 931f      	 push r17
000367 e0d0           ldi YH, high (dsp_buff_1)			; Load YH and YL as a pointer to 1st
000368 e6c0           ldi YL, low (dsp_buff_1)			; byte of dsp_buff_1 (Note - assuming 
                 										; (dsp_buff_1 for now).
000369 9105           lpm R16, Z+						; get dsply buff number (1st byte of msg).
00036a 3001           cpi r16, 1							; if equal to '1', ptr already setup.
00036b f061           breq get_msg_byte					; jump and start message load.
00036c 9660           adiw YH:YL, 16						; else set ptr to dsp buff 2.
00036d e010      	 ldi r17, $00
00036e e0a6      	 ldi r26, 6
00036f 3002           cpi r16, 2							; if equal to '2', ptr now setup.
000370 f061           breq digit_load					; jump and start message load.
000371 e010      	 ldi r17, $00
000372 e0a6      	 ldi r26, 6
000373 3005           cpi r16, 5							; if equal to '2', ptr now setup.
000374 f041           breq digit_load					; jump and start message load.
000375 3004      	 cpi r16, 4
000376 f009      	 breq get_msg_byte
000377 9660           adiw YH:YL, 16						; else set ptr to dsp buff 3.
                         
                 get_msg_byte:
000378 9105           lpm R16, Z+						; get next byte of msg and see if '0'.        
000379 3000           cpi R16, 0							; if equal to '0', end of message reached.
00037a f121           breq msg_loaded					; jump and stop message loading operation.
00037b 9309           st Y+, R16							; else, store next byte of msg in buffer.
00037c cffb           rjmp get_msg_byte					; jump back and continue...
                 
                 ;__________________________________________
                 ; digital_load will only be accessed when displaying line 2, 
                 ; since the frequency to be displayed in line 2 is constantly 
                 ; changing for different waveform, the line 2 has to be adjusted 
                 ; according. 
                 ; r17, will inc until 6, to display 6 empty spaces
                 ; r4 will contain the first digit of the frequency
                 ; r3 will contain the second digit of the frequency
                 ; r2 will contain the third digit of the frequency
                 ; r1 will contian the fouth digit of the frequency
                 ;get_dis_freq subroutine will just transfer each value stored in 
                 ; r25 to y pointer
                 ;_______________________________________________	
                 digit_load:
00037d e0b5      	ldi r27, 5
00037e 9513      	inc r17
00037f e290      	ldi r25, $20					;load empty spaces for 6 places
000380 d01c      	rcall get_dis_freq				;display 
000381 131a      	cpse r17, r26					;check if 6 places typed
000382 cffa      	rjmp digit_load					;repeat until 6 places
                 	;mov r25, r5						;load the first number in freq
                 	;rcall get_dis_freq				;display 
000383 2d94      	mov r25, r4					;load the first number in freq
000384 d018      	rcall get_dis_freq				;display 
000385 e29e      	ldi r25, $2E
000386 d016      	rcall get_dis_freq				;load period to display inbetween numbers
000387 2d93      	mov r25, r3					;load the second number in freq
000388 d014      	rcall get_dis_freq				;display 
000389 2d92      	mov r25, r2						;load the third number in freq
00038a d012      	rcall get_dis_freq				;display 
00038b 2d91      	mov r25, r1						;load the fourth number in freq
00038c d010      	rcall get_dis_freq				;display 
00038d 130b      	cpse r16, r27
00038e d00b      	rcall disp_volts				;display
00038f e290      	ldi r25, $20					;load empty spaces for 6 places
000390 d00c      	rcall get_dis_freq				;display 
000391 e290      	ldi r25, $20					;load empty spaces for 6 places
000392 d00a      	rcall get_dis_freq				;display 
000393 e290      	ldi r25, $20					;load empty spaces for 6 places
000394 d008      	rcall get_dis_freq				;display 
000395 e290      	ldi r25, $20					;load empty spaces for 6 places
000396 d006      	rcall get_dis_freq				;display 
000397 e290      	ldi r25, $20					;load empty spaces for 6 places
000398 d004      	rcall get_dis_freq				;display 
000399 c005      	rjmp msg_loaded					;go to the next line of the lcd
                 
                 disp_volts:
00039a e596      	ldi r25, $56					;load the fourth number in freq
00039b d001      	rcall get_dis_freq				;display 
00039c 9508      	ret
                 get_dis_freq:
00039d 9399      	st Y+, r25						;display the selected frquency
00039e 9508      	ret		
                 
                 	
                 msg_loaded:
00039f 911f      	 pop r17
0003a0 91af      	 pop r26
0003a1 9508           ret
                 ;________________________________________________________________________________________
                 
                 ;------------------------------------------------
                 ;unpacks the values store in r8 and r9 to r1- r4
                 ; r4 containe the left most number ie the thousanth
                 ;digit and r1 the right most number
                 ;------------------------------------------------
                 ;------------------------------------------------
                 ;unpacks the values store in r13 and r14 to r1- r4
                 ; r4 containe the left most number ie the thousanth
                 ;digit and r1 the right most number
                 ;------------------------------------------------
                 .def bit01 = r13				;values taken from bin2bcd
                 .def bit23 = r14
                 unpack:
0003a2 d018      	rcall bin2BCD16					;convert the values from binary to bcd
0003a3 930f      	push r16						;store the value currently in r16
0003a4 2c2d      	mov r2, bit01					;make a copy of r13 in r2
0003a5 2c4e      	mov r4, bit23					;make a copy of r14 in r4
0003a6 e00f      	ldi r16, $0f					;use and function to
0003a7 22d0      	and bit01, r16					;mask the upper nibble of r8
0003a8 2c1d      	mov r1, bit01					;move lower nibble to r1
0003a9 22e0      	and bit23, r16					;mask upper nibble of r9
0003aa 2c3e      	mov r3, bit23					;move lower nible to r3
0003ab 9500      	com r16							;load with f0 to mask lower nibble
0003ac 2220      	and r2, r16						;mask lower nibble of r8
0003ad 9422      	swap r2							;switch upper and lower nibble
0003ae 2240      	and r4, r16						;mask lower nibble of r9
0003af 9442      	swap r4							;switch upper and lower nibble
                 
0003b0 2ca4      	mov r10, r4
0003b1 2c73      	mov r7, r3
0003b2 2c62      	mov r6, r2
0003b3 2c51      	mov r5, r1						;copy the bcd values to r8-r5
0003b4 e300      	ldi r16, $30
0003b5 0e10      	add r1, r16
0003b6 0e20      	add r2, r16
0003b7 0e30      	add r3, r16
0003b8 0e40      	add r4, r16
0003b9 910f      	pop r16							;retrive the value previosly stored
0003ba 9508      	ret
                 
                 .undef bit01 
                 .undef bit23	
                 		
                 
                 
                 
                 
                 
                 
                 
                 ;_____________________________________________________________________________________
                 
                 
                 
                 
                 
                 ;***************************************************************************
                 ;*
                 ;* "bin2BCD16" - 16-bit Binary to BCD conversion
                 ;*
                 ;* This subroutine converts a 16-bit number (fbinH:fbinL) to a 5-digit
                 ;* packed BCD number represented by 3 bytes (tBCD2:tBCD1:tBCD0).
                 ;* MSD of the 5-digit number is placed in the lowermost nibble of tBCD2.
                 ;*
                 ;* Number of words	:25
                 ;* Number of cycles	:751/768 (Min/Max)
                 ;* Low registers used	:3 (tBCD0,tBCD1,tBCD2)
                 ;* High registers used  :4(fbinL,fbinH,cnt16a,tmp16a)	
                 ;* Pointers used	:Z
                 ;*
                 ;***************************************************************************
                 //.include "..\8515def.inc"
                 ;***** Subroutine Register Variables
                 
                 
                 .equ	AtBCD0	=13			;address of tBCD0
                 .equ	AtBCD2	=15			;address of tBCD1
                 
                 .def	tBCD0	=r13		;BCD value digits 1 and 0
                 .def	tBCD1	=r14		;BCD value digits 3 and 2
                 .def	tBCD2	=r15		;BCD value digit 4
                 .def	fbinL	=r16		;binary value Low byte
                 .def	fbinH	=r17		;binary value High byte
                 .def	cnt16a	= r18		;loop counter
                 .def	tmp16a	= r19		;temporary value
                 
                 ;***** Code
                 
                 bin2BCD16:
                 	//sub r18, r19
0003bb 2f13      	mov fbinH, r19			;copy the values of edge counter to fbin
0003bc 2f02      	mov fbinL, r18
0003bd e120      	ldi	cnt16a, 16			;Init loop counter	
0003be 24ff      	clr	tBCD2				;clear result (3 bytes)
0003bf 24ee      	clr	tBCD1		
0003c0 24dd      	clr	tBCD0		
0003c1 27ff      	clr	ZH					;clear ZH (not needed for AT90Sxx0x)
                 bBCDx_1:
0003c2 0f00      	lsl	fbinL				;shift input value
0003c3 1f11      	rol	fbinH				;through all bytes
0003c4 1cdd      	rol	tBCD0				;
0003c5 1cee      	rol	tBCD1
0003c6 1cff      	rol	tBCD2
0003c7 952a      	dec	cnt16a				;decrement loop counter
0003c8 f409      	brne bBCDx_2			;if counter not zero
0003c9 9508      	ret						;   return
                 
                 bBCDx_2:
0003ca e1e0      	ldi	r30,AtBCD2+1		;Z points to result MSB + 1
                 bBCDx_3:	
0003cb 9132      	ld	tmp16a,-Z			;get (Z) with pre-decrement
0003cc 5f3d      	subi tmp16a,-$03		;add 0x03
0003cd fd33      	sbrc tmp16a,3			;if bit 3 not clear
0003ce 8330      	st Z,tmp16a				;store back
0003cf 8130      	ld	tmp16a,Z			;get (Z)
0003d0 5d30      	subi tmp16a,-$30		;add 0x30
0003d1 fd37      	sbrc tmp16a,7			;if bit 7 not clear
0003d2 8330      	st	Z,tmp16a			;store back
0003d3 30ed      	cpi	ZL,AtBCD0			;done all three?
0003d4 f7b1      	brne bBCDx_3			;loop again if not
0003d5 cfec      	rjmp bBCDx_1	
                 
                 .undef	tBCD0				;BCD value digits 1 and 0
                 .undef	tBCD1				;BCD value digits 3 and 2
                 .undef	tBCD2				;BCD value digit 4
                 .undef	fbinL				;binary value Low byte
                 .undef	fbinH				;binary value High byte
                 .undef	cnt16a				;loop counter
                 .undef	tmp16a				;temporary value
                 
                 
                 
                 ;------------DELAY 10 MS--------------------------
                 ;This subroutine is placed here, if it was required during 
                 ; the lab. Its not called anywhere in the code. 
                 ;delays for 10ms 
                 ;r20 set to 100
                 ;r21 set to 33
                 ; combined delay will yield 9999 clock cycles
                 ;-------------------------------------------------
                 delay:
0003d6 930f      	push r16
0003d7 931f      	push r17
0003d8 e604      	ldi r16,100
                 	outer:
0003d9 e211      		ldi r17, 33
                 		inner:
0003da 951a      			dec r17
0003db f7f1      			brne inner
0003dc 950a      			dec r16
0003dd f7d9      			brne outer
0003de 911f      	pop r17
0003df 910f      	pop r16
0003e0 9508      	ret


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega16" register use summary:
r0 :   0 r1 :   4 r2 :   6 r3 :   4 r4 :   6 r5 :   2 r6 :   6 r7 :   3 
r8 :   8 r9 :   9 r10:   7 r11:   0 r12:   0 r13:   5 r14:   5 r15:   2 
r16: 148 r17:  32 r18:  32 r19:  32 r20:   8 r21:  20 r22:   2 r23:  10 
r24:   8 r25:  27 r26:   7 r27:   2 r28:   3 r29:   3 r30:  33 r31:  32 
x  :   0 y  :   2 z  :  10 
Registers used: 31 out of 35 (88.6%)

"ATmega16" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   5 adiw  :   2 and   :   5 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   1 break :   0 breq  :  17 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  27 brpl  :   0 brsh  :   6 brtc  :   2 brts  :   3 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  10 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   7 cls   :   0 
clt   :   6 clv   :   0 clz   :   0 com   :   2 cp    :   8 cpc   :   0 
cpi   :  21 cpse  :   2 dec   :  21 eor   :   5 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  17 inc   :   4 jmp   :   3 
ld    :   5 ldd   :   0 ldi   : 156 lds   :   0 lpm   :   2 lsl   :   1 
lsr   :   0 mov   :  35 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :   4 or    :   0 ori   :   0 out   :  25 pop   :  25 
push  :  25 rcall : 129 ret   :  35 reti  :   2 rjmp  :  48 rol   :   6 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :  27 sbic  :   2 sbis  :  20 
sbiw  :   0 sbr   :   0 sbrc  :   2 sbrs  :   5 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   3 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   5 std   :   0 sts   :   0 
sub   :   1 subi  :   2 swap  :   7 tst   :   0 wdr   :   0 
Instructions used: 47 out of 113 (41.6%)

"ATmega16" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0007c2   1504    462   1966   16384  12.0%
[.dseg] 0x000060 0x000090      0     48     48    1024   4.7%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
