
AVRASM ver. 2.1.52  C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\LAB 9\vm1b\vm1b\vm1b.asm Tue Nov 04 19:30:00 2014

C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\LAB 9\vm1b\vm1b\vm1b.asm(31): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.39.1005\avrassembler\Include\m16def.inc'
C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\LAB 9\vm1b\vm1b\vm1b.asm(355): Including file 'C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\LAB 9\vm1b\vm1b\lcd_dog_asm_driver_m16A.inc'
C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\LAB 9\vm1b\vm1b\vm1b.asm(640): warning: Register r18 already defined by the .DEF directive
C:\Users\radra_000\Box Sync\college sophomore fall 2014\fall 2014 notes and files\ese 380 lab\LAB 9\vm1b\vm1b\vm1b.asm(641): warning: Register r19 already defined by the .DEF directive
                 
                 
                  * vm1b.asm
                  *
                  * Lab 9 - 
                  *
                  ; This program will continuously read the voltage values coming in through
                  ; port a pin 4, it will convert the analog signal to a digital signal. This 
                  ; all done by processor, only initialization of the adc converters are required. 
                  ; the converterted value 10 bit value is then sent to multiply with 50 and then 
                  ; divide subroutine to divide by 10. Both of these subrouitnes are provided by atmel 
                  ; the value obtained is then unpacked and displayed on the display. the process is '
                  ; repeated forever. The only thing different about this program compared to the first 
                  ; is that this will utilize an external interrupt to toggle between run and hold. 
                  ; when its in run mode the code will read the input analog voltage. when its in hold 
                  ; mode it will retain the value, and doesnt read again until the pbsw is pressed again.
                  ; registers used by code written by me
                  ; r1 - r5 to unpack the bits
                  ; r8 and r9 to copy the 10 bit value obtained after convertion
                  ; r16 for general purpose like initilization etc
                  ; r17 as a space counter used in the display subroutine
                  ; r28 initialized to 6. to keep r17 in check 
                  ; r27 as a toggle register. changes between 1 or 0 with press of center button 
                  ;r8 and r9 will be used to store the adc conversion values
                  *  Created: 10/29/2014 2:17:13 PM
                  *   Author: radra_000
                  */
                  
                 
                  
                 .LIST 
                 
                 
                  ;********************************************************************
                 	 .cseg 
                 	 .org 0								;reset/restart code entry point <<<<<<<< 
000000 940c 0004 	 jmp reset	
                 	 
                 	 
                 	 
                 	 //when the counter is equal to 1s, the interrupt will be called
                 	 //0x0E is the adress for timer compare match B. 
                 	 //when the interrupt is called, it will jump to isr_tc0_display
                 	 .org 0x002							;when external interrupt is pressed
000002 940c 003c 	 jmp switch							;its located on pd2
                 
                 	// .org 0x00E							; timer intrrupt
                 	// jmp isr_tc0_display				;goes here when the time is up
                 
                 
                 reset:
000004 e50f      	ldi r16, low(ramend)
000005 bf0d      	out spl, r16
000006 e004      	ldi r16, high(ramend)
000007 bf0e      	out sph, r16						;initialize stack pointer
000008 e003      	LDI r16,$03
000009 bf05      	out mcucr, r16
00000a e400      	ldi r16, 1 << INT0
00000b bf0b      	out gicr, r16
00000c e000      	ldi r16, $00
00000d bb01      	out ddrd, r16						;set up the port b as inputs to read the pbsw values
                 										; and nand gate input on pd(2)
                 
00000e ef0f      	ldi r16, 0xff						; set portB = output.
00000f bb02      	out portd, r16
000010 bb07          out DDRB, r16						; for lcd display
000011 9ac4          sbi portB, 4					   	; set /SS of DOG LCD = 1 (Deselected)1
                 
000012 e001      	ldi r16, 1							; set DDRC for all in but PC0
000013 bb04      	out DDRC, r16
000014 9aa8      	sbi PortC, 0						; turn off sounder
                 
000015 e400      	ldi r16,0b01000000					; set up port a to 
000016 bb0a      	out ddra, r16						;read the frequency input on pa7 and output pulse on pa6
                 
000017 d0cd      	rcall init_lcd_dog					; init display, using SPI serial interface 
                 
                 	
                 	//rcall start_tc1					;init the timer counter 1
000018 d01e      	rcall adc_init
000019 e0b1      	ldi r27, 1							;initialization of r27
00001a 9468      	set
                 
                 
                 main:
00001b f42e      	brtc hold							;if cleared just display the existing value
00001c d00a      	rcall conv_check					;check if the conversion is complete
00001d d13b      	rcall unpack						;convert the answer to ascii
00001e d034      	rcall display						;display the measured value
00001f f026      	brts read_next						;if t flag is set then read the next value
000020 cffa      	rjmp main
                 
                 	hold:
000021 ffb0      		sbrs r27, 0						;skip T flag is set, meaning its in run mode
000022 d030      		rcall display					; wait until, the hold is released
000023 cff7      		rjmp main	
                 	read_next:
000024 9a36      		sbi ADCSRA, ADSC				;start the next conversion 
000025 cff5      		rjmp main
                 end:
000026 cff4      	rjmp main								
                 ;*********************converion check***************************
                 ; checks if  ADIF flag is set in the adscra register. 
                 ; when the flag is 1 it means that the conversion is complete,
                 ; so reset the flag, convert the bits stored in adch and adcl register 
                 ; and covert
                 ;display the converted value, by branching to display subroutine
                 conv_check:
                 	;for simulation purpose
                 	//rjmp func_conv
                 	;
000027 9b34      	sbis ADCSRA, ADIF					;check if the adif flag is set or conversion done
000028 c001      	rjmp func_conv						;when set jump to func_conv
000029 cffd      	rjmp conv_check
                 
                 	func_conv:
                 	//ask weather to disable the conversion and renable after flag
00002a e000      		ldi r16, 0<<adif
00002b b906      		out adcsra, r16					;reset the adif flag
00002c b084      		in r8, ADCL						;read the conversion values
00002d b095      		in r9, ADCH
                 	
                 	arithmatic:
00002e d166      		rcall mpy16u					;multiply the counts with 50
00002f d178      		rcall div32u					;divide the counts by 10
000030 9508      		ret								;go back and display
                 		
                 
                 ;*********************TIMER INITIALIZATION*************************** 
                 ; THE COUNTER, FLAGS ARE INITIALIZED.
                 ;*******************************************************************
                 	
                 start_tc1:	
                 //intialization for the timer
                 	/*ldi r16, $00
                 	out TCNT1H, r16						; set up counter with 0's
                 	out TCNT1L, r16						;*/
                 	;Init Timer/counter Interrupt MaSK (TIMSK) register to enable/set 
000031 e008      	ldi r16, 8							;load with bcd 1000, this will enable the 
                 										;"ocie1b" which is located in bit 4 of the register. 
                 										;refer to datasheet pg 115 for details
000032 bf09      	out TIMSK, r16						;set up the timer interrupt
                 
000033 e200      	ldi r16, 1<<ICF1					;loading the timer interrupt flag register
000034 bf08      	out TIFR, r16						;
                 
                 
                 	
000035 9478      	sei									;enable global interrupts...
                 
                 
                 	;TCCR1B = FOC0 : WGM11 : COM11 : COM10 : WGM11 : CS12 : CS11 : CS10 
                 	; 0 0 0 0 0 0 1 1 
                 	; FOC Off; No WF Gen; COM=Nrml Port Op; Pre-scaler= 1/64 
                  
                 
000036 9508      	ret
                 ;_______________________________________________________________________
                 
                 
                 ;*****************ADC initialization**************************
                  ;intializes all the required registers located in port A, for 
                  ; analag to digital conversion. 
                  ; registers to be initialized:
                  ; ADMUX - adc multiplexer selection register
                  ; REFS1  REFS0  ADLAR  MUX4  MUX3  MUX2  MUX1  MUX0
                  ; 
                  ; REFS1 and REFS0 will be both set to 1, in order to get 2.56v 
                  ; internal voltage reference, refer to pg(471). 
                  ; Adlar -  by default is right adjusted.
                  ;
                  ; ADCSRA - adc control and status register A
                  ; ADEN  ADSC  ADATE  ADIF ADIE  ADPS2  ADPS1  ADPS0
                  ; 
                  ; ADEN: ADC ENABLE
                  ; ADSC - TO START CONVERSION 
                  ; 
                  ; SFIOR - Special functions io register
                  ; ADTS2  ADTS1  ADTS0
                  ;	7		6		5
                  ; THE above three bits could be used to set various interrupts
                  adc_init:
                  
000037 ec04      	ldi r16, 0b11000100					;load 16 to set the ADC4 and single ended
000038 b907      	out admux, R16						;input and internal voltage reference to 2.56v
                 										; the conversion is running in single run mode
                 	;the below code can be placed wherever its required to start the conversion
000039 ec04      	ldi r16, 0b11000100					; for this lab we will be using a division factor
00003a b906      	out adcsra, r16						; of 16(clk/16)
                 	
                 	;ldi r16, 0b01000000				;could be used to set the enternal int 0
                 	;out sfior, r16		
00003b 9508      	ret
                 ;_________________________________________________________________________________________
                 
                 /*******************************When swich is pressed****************************
                  switch
                        This subroutine debounces the input coming in from port d and then 
                         complements r27 where if it is cleared frequency meter 2 will be 
                         executed and the other frequency meter is executed otherwise. 
                 *********************************************************************************/
                 switch:
00003c 930f      	push r16
00003d b70f      	in r16, sreg
00003e 930f      	push r16
00003f 931f      	push r17
000040 b300      	in r16, pind
000041 9500      	com r16
000042 7800      	andi r16,$80						;check if center pushbutton is pressed
000043 d183      	rcall delay
000044 b310      	in r17, pind	
000045 9510      	com r17
000046 7810      	andi r17, $80						;check if button is still pressed
000047 2310      	and r17,r16
000048 95b0      	com r27								;if pressed complement r27 everytime
000049 f001      	breq finish1
                 	
                 finish1:
00004a ff10      	sbrs r17, 0							;check if r27 is 1
00004b 94e8      	clt									; if 0 clear t flag
00004c fd10      	sbrc r17, 0							;check if r27 is 0
00004d 9468      	set									;if 1 set the t flag
00004e 911f      	pop r17
00004f 910f      	pop r16
000050 bf0f      	out sreg, r16
000051 910f      	pop r16
000052 9518      	reti
                 
                 ;**************************************************************************
                 ;---------------------------- SUBROUTINES ----------------------------
                 
                 ;*********************LCD DISPLAY CODE******************************
                 
                 ;---------------------------------------------------------
                 ;Code to load and display each line on the lcd 
                 ;r25 is used to load the value of the each digit to the pointer
                 ;line 2 refers to table, which containes numbers and depending 
                 ;on the frequncy, each number is picked and displayed 
                 ;---------------------------------------------------------
                 	
                 display:
000053 d0d4         rcall clr_dsp_buffs					; clear all three buffer lines
000054 d0ae         rcall update_lcd_dog					;
000055 ffb0        sbrs r27, 0							;if the last bit is 1 
000056 c002        rjmp regular1
000057 fdb0        sbrc r27, 0
000058 c01e        rjmp regular2
                    
                 regular1:
                 
                    ;load 1st line of prompt message into dbuff1
000059 e0f0         ldi  ZH, high(line1_message<<1)		;
00005a ece8         ldi  ZL, low(line1_message<<1)		;
00005b d0d4         rcall load_msg						; load message into buffer(s).
                 
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
00005c e0f0         ldi ZH, high(line2_message<<1)		;
00005d edea         ldi ZL, low(line2_message<<1)		;load the table to stack
00005e d0d1         rcall load_msg						;load the frequency number into the buffer
                    
                 
                    ;load 3rd line of prompt message into dbuff3
00005f e0f0         ldi  ZH, high(line3_message<<1)		;
000060 edec         ldi  ZL, low(line3_message<<1)		;
000061 d0ce         rcall load_msg						; load message into buffer(s).
000062 d0a0         rcall update_lcd_dog
000063 cfb7         rjmp main
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 .cseg 
000064 2a01
000065 2a2a
000066 2a2a
000067 6f56
000068 746c
000069 6761
00006a 2a65
00006b 2a2a
00006c 002a      line1_message:	.db 1, "*****Voltage****", 0  ; test string for line #1.
00006d 0002      line2_message:	.db 2,"",0
00006e 5203
00006f 4e55
000070 2020
000071 2020
000072 2020
000073 2020
000074 5620
000075 314d
000076 0042      line3_message:	.db 3, "RUN         VM1B", 0  ; test string for line #3.
                 
                 
                 
                 regular2:
                 
                    ;load 1st line of prompt message into dbuff1
000077 e0f1         ldi  ZH, high(line1_message0<<1)		;
000078 e0e4         ldi  ZL, low(line1_message0<<1)		;
000079 d0b6         rcall load_msg						; load message into buffer(s).
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
00007a e0f1         ldi ZH, high(line2_message0<<1)		;
00007b e1e6         ldi ZL, low(line2_message0<<1)		;load the table to stack
00007c d0b3         rcall load_msg						;load the frequency number into the buffer
                    
                    ;load 3rd line of prompt message into dbuff3
00007d e0f1         ldi  ZH, high(line3_message0<<1)		;
00007e e1e8         ldi  ZL, low(line3_message0<<1)		;
00007f d0b0         rcall load_msg						; load message into buffer(s).
000080 d082         rcall update_lcd_dog
                 /*;for bonus
                 	ldi r16, 50
                 	delay_500ms
                 	rcall delay
                 	dec r16
                 	brne delay_500ms
                 	brts end
                 	rjmp regular2_blink
                 	*/
000081 cf99         rjmp main
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
000082 2a01
000083 2a2a
000084 2a2a
000085 6f56
000086 746c
000087 6761
000088 2a65
000089 2a2a
00008a 002a      line1_message0:	.db 1, "*****Voltage****", 0  ; test string for line #1.
00008b 0002      line2_message0:	.db 2,"",0
00008c 4803
00008d 4c4f
00008e 2044
00008f 2020
000090 2020
000091 2020
000092 5620
000093 314d
000094 0042      line3_message0:	.db 3, "HOLD        VM1B", 0  ; test string for line #3.
                 
                 regular2_blink:
                 
                    ;load 1st line of prompt message into dbuff1
000095 e0f1         ldi  ZH, high(line1_message2<<1)		;
000096 e3ee         ldi  ZL, low(line1_message2<<1)		;
000097 d098         rcall load_msg						; load message into buffer(s).
                 
                    ;LOAD 2ND LINE OF THE MESSAGE INTO DBUFF2
000098 e0f1         ldi ZH, high(line2_message2<<1)		;
000099 e5e0         ldi ZL, low(line2_message2<<1)		;load the table to stack
00009a d095         rcall load_msg						;load the frequency number into the buffer
                    
                    ;load 3rd line of prompt message into dbuff3
00009b e0f1         ldi  ZH, high(line3_message2<<1)		;
00009c e5e2         ldi  ZL, low(line3_message2<<1)		;
00009d d092         rcall load_msg						; load message into buffer(s).
00009e d064         rcall update_lcd_dog
                 /*;for bonus
                 	ldi r16, 50
                 	delay_500ms
                 	rcall delay
                 	dec r16
                 	brne delay_500ms
                 	brts end
                 	rjmp regular2
                 	*/
                    
                 ;--------------------------------------
                 ;lines to display on the lcd
                 ;--------------------------------------
                 
                 .cseg
00009f 2a01
0000a0 2a2a
0000a1 2a2a
0000a2 6f56
0000a3 746c
0000a4 6761
0000a5 2a65
0000a6 2a2a
0000a7 002a      line1_message2:	.db 1, "*****Voltage****", 0  ; test string for line #1.
0000a8 0002      line2_message2:	.db 2,"",0
0000a9 2003
0000aa 2020
0000ab 2020
0000ac 2020
0000ad 2020
0000ae 2020
0000af 5620
0000b0 314d
0000b1 0042      line3_message2:	.db 3, "            VM1B", 0  ; test string for line #3.
                 
                 ;______________________________________________________________________________________
                 
                 ;====================================
                 .include "lcd_dog_asm_driver_m16A.inc"  ; LCD DOG init/update procedures.
                 
                 ;modified 11/26/12 KLS
                 ; lcd_spi_transmit_data and lcd_spi_transmit_CMD handling of SPIF flag
                 ;
                 ;modifued 07/21/14 FST
                 ; added BLOCK comments for adjusting power_ctrl & contrast_set parameters
                 ;
                 
                 
                 ;************************************************************************ 
                 ;   ATMega16A  2015 Version                           PRINT IN LANDSCAPE                     
                 ;   
                 ;   This AVR-asm code module is usable as an include file for assembly
                 ;   language and or mixed asm/C application programs. The code is freely 
                 ;   usable by any University of Stonybrook undergraduate students for any
                 ;   and all not-for-profit system designs and or implementations.
                 ;
                 ;   This code is designed to be executed on an AVR ATMega micro-computer.
                 ;   And may be readily adapted for compatibility with IAR/AVR compilers. 
                 ;   See the IAR assembler reference guide for more information by 
                 ;   clicking 'Help > AVR Assembly Reference Guide" on the above menus.
                 ;
                 ;
                 ;************************************************************************
                 ;
                 ;   This module contains procedures to initialize and update
                 ;   DOG text based LCD display modules, including the EA DOG163M LCD
                 ;   modules configured with three (3) 16 charactors display lines.
                 ;
                 ;   The display module hardware interface uses a 1-direction, write only
                 ;   SPI interface. (See below for more information.)
                 ;
                 ;   The display module software interface uses three (3) 16-byte
                 ;   data (RAM) based display buffers - One for each line of the display.
                 ;   (See below for more information.)
                 ;
                 ;*********************************************************************
                 ;
                 ;   *** Port B Interface Definitions:
                 ;
                 ;  Port B             PB7   PB6   PB5   PB4   PB3   PB2   PB1   PB0
                 ;  Port B alt names   SCK   MISO  MOSI  /SS   /RS    -     -     -
                 ;  LCD Mod Signal     D6     -     D7   /CSB   -     -     -     -
                 ;  LCD Mod Pin #      29     -     28    38    -     -     -     -
                 ;
                 ;  Notes: RS ==>  0 = command regs, 1 = data regs
                 ;         /SS = active low SPI select signal
                 ;
                 ;******************
                 
                 
                 ;***  DATA Segment  **************************************************   
                 .DSEG
000060           dsp_buff_1:   .byte 16
000070           dsp_buff_2:   .byte 16
000080           dsp_buff_3:   .byte 16
                 
                 
                 
                 
                 ;***  CODE Segment Subroutines  ************************************
                 .CSEG
                 
                 
                 
                 ;************************
                 ;NAME:        delay_30uS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R24, SREG
                 ;CALLED BY:   init_dsp
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             30 uS (assuming a 1 MHz clock).
                 ;********************************************************************
0000b2 0000      delay_30uS:   nop     ; fine tune delay
0000b3 0000                    nop
0000b4 938f                    push  r24
0000b5 e08f                    ldi   r24, 0x0f  ; load delay count.
0000b6 958a      d30_loop:     dec   r24        ; count down to
0000b7 f7f1                    brne  d30_loop   ; zero.
0000b8 918f                    pop   r24
0000b9 9508                    ret
                 
                 
                 
                 ;*********************
                 ;NAME:        v_delay
                 ;ASSUMES:     R22, R23 = initial count values defining how many
                 ;             30uS delays will be called. This procedure can generate
                 ;             short delays (r23 = small #) or much longer delays (where
                 ;             R23 value is large).
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22, R23, SREG
                 ;CALLED BY:   init_dsp, plus...
                 ;DESCRIPTION: This procedure will generate a variable delay for a fixed
                 ;             period of time based the values pasted in R24 and R25.
                 ;
                 ;Sample Delays:
                 ;
                 ;             R22  R23  DelayTime
                 ;             ---  ---  ---------
                 ;              1    1   ~65.5 uS
                 ;              0    1   ~14.2 mS
                 ;              0    9   ~130 mS
                 ;**********************************************************************
0000ba dff7      v_delay:      rcall delay_30uS ; delay for ~30uS
0000bb 956a                    dec   r22      ; decrement inner loop value, and
0000bc f7e9                    brne  v_delay  ; loop until zero.
0000bd 957a                    dec   r23      ; decr outer loop count, and loop back
0000be f7d9                    brne  v_delay  ; to inner loop delay until r23 zero.
0000bf 9508                    ret
                 
                 
                 
                 
                 ;***********************
                 ;NAME:        delay_40mS
                 ;ASSUMES:     nothing
                 ;RETURNS:     nothing
                 ;MODIFIES:    R22,R23, SREG
                 ;CALLED BY:   init_dsp, ????
                 ;DESCRIPTION: This procedure will generate a fixed delay of just over
                 ;             40 mS.
                 ;********************************************************************
0000c0 e060      delay_40mS:   ldi   r22,0        ; load inner loop var
0000c1 e074                    ldi   r23,4        ; load outer loop var
0000c2 dff7                    rcall  v_delay     ; delay
0000c3 9508                    ret
                 
                 
                 
                 
                 ;************************
                 ;NAME:       init_spi_lcd
                 ;ASSUMES:    IMPORTANT: PortB set as output (during program init)
                 ;RETURNS:    nothing
                 ;MODIFIES:   DDRB, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: init SPI port for command and data writes to LCD via SPI
                 ;********************************************************************
                 init_spi_lcd:
0000c4 930f            push r16
0000c5 e50c            ldi r16,(1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA)
0000c6 b90d            out SPCR,r16   ; Enable SPI, Master, fck/4, 
                       
                       ;kill any spurious data...
0000c7 b10e            in r16, SPSR   ; clear SPIF bit in SPSR
0000c8 b10f            in r16, SPDR   ;
0000c9 910f            pop r16        ; restore r16 value...
0000ca 9508            ret
                 
                 
                 
                 ;********************************
                 ;NAME:       lcd_spi_transmit_CMD
                 ;ASSUMES:    r16 = byte for LCD.
                 ;            SPI port is configured.
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, PortB, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: outputs a byte passed in r16 via SPI port. Waits for data
                 ;            to be written by spi port before continuing.
                 ;*********************************************************************
                 lcd_spi_transmit_CMD:
0000cb 930f           push r16          ; save command, need r16.
0000cc 98c3           cbi   portB, 3    ; clr PB1 = RS = 0 = command.
0000cd 98c4           cbi   portB, 4    ; clr PB2 = /SS = selected.
0000ce b10e              in r16, SPSR   ; clear SPIF bit in SPSR.
0000cf b10f              in r16, SPDR   ;
0000d0 910f           pop r16           ; restore command
0000d1 b90f           out SPDR,r16      ; write data to SPI port.
                 
                 
                      ;Wait for transmission complete
                 wait_transmit:
0000d2 b10e           in r16, SPSR     ; read status reg
0000d3 ff07           sbrs r16, SPIF   ; if bit 7  = 0 wait
0000d4 cffd           rjmp wait_transmit
0000d5 b10f      	 in r16, SPDR		;added by Ken to clear SPIF
0000d6 9ac4           sbi   portB, 4   ; set PB2 = /SS = deselected
0000d7 9508           ret
                 
                 
                 
                 
                 ;*********************************
                 ;NAME:       lcd_spi_transmit_DATA
                 ;ASSUMES:    r16 = byte to transmit to LCD.
                 ;            SPI port is configured.
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, SPCR
                 ;CALLED BY:  init_dsp, update
                 ;DESCRITION: outputs a byte passed in r16 via SPI port. Waits for
                 ;            data to be written by spi port before continuing.
                 ;*****************************************************************
                 lcd_spi_transmit_DATA:
0000d8 930f           push r16          ; save command, need r16.
0000d9 9ac3           sbi   portB, 3    ; clr PB1 = RS = 1 = data.
0000da 98c4           cbi   portB, 4    ; clr PB2 = /SS = selected.
0000db b10e              in r16, SPSR   ; clear SPIF bit in SPSR.
0000dc b10f              in r16, SPDR   ;
0000dd 910f           pop r16           ; restore command.
0000de b90f           out SPDR,r16      ; write data to SPI port.
                 
                 
                      ;Wait for transmission complete
                 wait_transmit1:
0000df b10e           in r16, SPSR     ; read status reg
0000e0 ff07           sbrs r16, SPIF   ; if bit 7  = 0 wait
0000e1 cffd           rjmp wait_transmit1
0000e2 b10f      	 in r16, SPDR		;clear SPIF (because it follows in r16,SPSR)
0000e3 9ac4           sbi   portB, 4   ; set PB2 = /SS = deselected
0000e4 9508           ret
                 
                 
                 
                 ;************************
                 ;NAME:       init_lcd_dog
                 ;ASSUMES:    nothing
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16, R17
                 ;CALLED BY:  main application
                 ;DESCRITION: inits DOG module LCD display for SPI (serial) operation.
                 ;NOTE:  Can be used as is with MCU clock speeds of 4MHz or less.
                 ;********************************************************************
                 ; public __version_1 void init_dsp(void)
                 init_lcd_dog:
0000e5 dfde             rcall init_spi_lcd   ; init SPI port for DOG LCD.
                 
                 
                 start_dly_40ms:
0000e6 dfd9             rcall  delay_40mS    ; startup delay.
                 
                 
                 func_set1:
0000e7 e309             ldi    r16,0x39      ; send fuction set #1
0000e8 dfe2             rcall  lcd_spi_transmit_CMD   ;
0000e9 dfc8             rcall  delay_30uS    ; delay for command to be processed
                 
                 
                 func_set2:
0000ea e309             ldi    r16,0x39      ; send fuction set #2
0000eb dfdf             rcall  lcd_spi_transmit_CMD
0000ec dfc5             rcall  delay_30uS    ; delay for command to be processed
                 
                 
                 bias_set:
0000ed e10e             ldi    r16,0x1E      ; set bias value.
0000ee dfdc             rcall  lcd_spi_transmit_CMD
0000ef dfc2             rcall  delay_30uS    ;
                 
                 
                                                    ; =============================================
                                                    ; === CALIBRATION PARAMETER - USER ADJUSTABLE
                 power_ctrl:                        ; === (CAUTION... VERY DELICATE ADJUSTMENT)
0000f0 e500             ldi    r16,0x50             ; === 5V ~= 0x50 nominal;      Adjust by 1 ONLY
0000f1 dfd9             rcall  lcd_spi_transmit_CMD ; === 3.3V ~= 0x55 nominal     and think hex!
0000f2 dfbf             rcall  delay_30uS           ;   Hex = 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f
                                                    ; ==========================================
                 
                 follower_ctrl:
0000f3 e60c             ldi    r16,0x6C      ; follower mode on... 
0000f4 dfd6             rcall  lcd_spi_transmit_CMD
0000f5 dfca             rcall  delay_40mS    ;
                                                    ; ============================================
                                                    ; === CALIBRATION PARAMETER - USER ADJUSTABLE
                 contrast_set:                      ; === LCD CONTRAST SETTING ADJUSTMENT
0000f6 e707             ldi    r16,0x77             ; === 
0000f7 dfd3             rcall  lcd_spi_transmit_CMD ; === Delicate: increases for 3.3V vs 5V
0000f8 dfb9             rcall  delay_30uS           ; ========================================= 
                 
                 display_on:
0000f9 e00c             ldi    r16,0x0c      ; display on, cursor off, blink off
0000fa dfd0             rcall  lcd_spi_transmit_CMD
0000fb dfb6             rcall  delay_30uS    ; 
                 
                 
                 clr_display:
0000fc e001             ldi    r16,0x01      ; clear display, cursor home
0000fd dfcd             rcall  lcd_spi_transmit_CMD
                 
                 
0000fe dfb3             rcall  delay_30uS    ;
                 
                 
                 entry_mode:
0000ff e006             ldi    r16,0x06      ; clear display, cursor home
000100 dfca             rcall  lcd_spi_transmit_CMD;
000101 dfb0             rcall  delay_30uS    ;
000102 9508             ret
                 
                 
                 
                 
                 ;**************************
                 ;NAME:       update_lcd_dog
                 ;ASSUMES:    display buffers loaded with display data
                 ;RETURNS:    nothing
                 ;MODIFIES:   R16,R20,R30,R31,SREG
                 ;
                 ;DESCRITION: Updates the LCD display lines 1, 2, and 3, using the
                 ;  contents of dsp_buff_1, dsp_buff_2, and dsp_buff_3, respectively.
                 ;*******************************************************************
                 ; public __version_1 void update_dsp_dog (void)
                 update_lcd_dog:
000103 dfc0             rcall init_spi_lcd    ; init SPI port for LCD.
000104 e140             ldi   r20,16          ; init 'chars per line' counter.
000105 934f             push  r20             ; save for later used.
                 
                 
                        ;send line 1 to the LCD module.
                 wr_line1:     
000106 e0f0             ldi   ZH, high (dsp_buff_1)  ; init ptr to line 1 display buffer.
000107 e6e0             ldi   ZL, low (dsp_buff_1)   ;
                 snd_ddram_addr:
000108 e800             ldi   r16,0x80             ; init DDRAM addr-ctr 
000109 dfc1             rcall lcd_spi_transmit_CMD ; 
00010a dfa7             rcall delay_30uS
                 snd_buff_1:
00010b 9101             ld    r16, Z+
00010c dfcb             rcall lcd_spi_transmit_DATA
00010d dfa4             rcall delay_30uS
00010e 954a             dec   r20
00010f f7d9             brne  snd_buff_1
                 
                 
                        ;send line 2 to the LCD module.
                 init_for_buff_2:
000110 914f             pop   r20     ; reload r20 = chars per line counter
000111 934f             push  r20     ; save for line 3
                 wr_line2:
000112 e0f0             ldi   ZH, high (dsp_buff_2)  ; init ptr to line 2 display buffer.
000113 e7e0             ldi   ZL, low (dsp_buff_2)
                 snd_ddram_addr2:
000114 e900             ldi   r16,0x90               ; init DDRAM addr-ctr 
000115 dfb5             rcall lcd_spi_transmit_CMD           ;  
000116 df9b             rcall delay_30uS
                 snd_buff_2:
000117 9101             ld    r16, Z+
000118 dfbf             rcall lcd_spi_transmit_DATA
000119 df98             rcall delay_30uS
00011a 954a             dec   r20
00011b f7d9             brne  snd_buff_2
                 
                 
                        ;send line 3 to the LCD module.
                 init_for_buff_3:
00011c 914f             pop   r20     ; reload r20 = chars per line counter
                 wr_line3:
00011d e0f0             ldi   ZH, high (dsp_buff_3)  ; init ptr to line 2 display buffer.
00011e e8e0             ldi   ZL, low (dsp_buff_3)
                 snd_ddram_addr3:
00011f ea00             ldi   r16,0xA0               ; init DDRAM addr-ctr 
000120 dfaa             rcall lcd_spi_transmit_CMD           ;  
000121 df90             rcall delay_30uS
                 
                 
                 snd_buff_3:
000122 9101             ld    r16, Z+
000123 dfb4             rcall lcd_spi_transmit_DATA
000124 df8d             rcall delay_30uS
000125 954a             dec   r20
000126 f7d9             brne  snd_buff_3
000127 9508             ret
                 
                 
                 ;******* End Of LCD DOG Include Module *********************************
                 ;====================================
                 
                 ;************************
                 ;NAME:      clr_dsp_buffs
                 ;FUNCTION:  Initializes dsp_buffers 1, 2, and 3 with blanks (0x20)
                 ;ASSUMES:   Three CONTIGUOUS 16-byte dram based buffers named
                 ;           dsp_buff_1, dsp_buff_2, dsp_buff_3.
                 ;RETURNS:   nothing.
                 ;MODIFIES:  r25,r26, Z-ptr
                 ;CALLS:     none
                 ;CALLED BY: main application and diagnostics
                 ;********************************************************************
                 clr_dsp_buffs:
000128 e390           ldi R25, 48						; load total length of both buffer.
000129 e2a0           ldi R26, ' '						; load blank/space into R26.
00012a e0f0           ldi ZH, high (dsp_buff_1)			; Load ZH and ZL as a pointer to 1st
00012b e6e0           ldi ZL, low (dsp_buff_1)			; byte of buffer for line 1.
                    
                     ;set DDRAM address to 1st position of first line.
                 store_bytes:
00012c 93a1           st  Z+, R26						; store ' ' into 1st/next buffer byte and
                 										; auto inc ptr to next location.
00012d 959a           dec  R25							; 
00012e f7e9           brne store_bytes					; cont until r25=0, all bytes written.
00012f 9508           ret
                 
                 
                 ;*******************
                 ;NAME:      load_msg
                 ;FUNCTION:  Loads a predefined string msg into a specified diplay
                 ;           buffer.
                 ;ASSUMES:   Z = offset of message to be loaded. Msg format is 
                 ;           defined below.
                 ;RETURNS:   nothing.
                 ;MODIFIES:  r16, Y, Z
                 ;CALLS:     nothing
                 ;CALLED BY:  
                 ;********************************************************************
                 ; Message structure:
                 ;   label:  .db <buff num>, <text string/message>, <end of string>
                 ;
                 ; Message examples (also see Messages at the end of this file/module):
                 ;   msg_1: .db 1,"First Message ", 0   ; loads msg into buff 1, eom=0
                 ;   msg_2: .db 1,"Another message ", 0 ; loads msg into buff 1, eom=0
                 ;
                 ; Notes: 
                 ;   a) The 1st number indicates which buffer to load (either 1, 2, or 3).
                 ;   b) The last number (zero) is an 'end of string' indicator.
                 ;   c) Y = ptr to disp_buffer
                 ;      Z = ptr to message (passed to subroutine)
                 ;********************************************************************
                 load_msg:
000130 93af      	 push r26
000131 931f      	 push r17
000132 e0d0           ldi YH, high (dsp_buff_1)			; Load YH and YL as a pointer to 1st
000133 e6c0           ldi YL, low (dsp_buff_1)			; byte of dsp_buff_1 (Note - assuming 
                 										; (dsp_buff_1 for now).
000134 9105           lpm R16, Z+						; get dsply buff number (1st byte of msg).
000135 3001           cpi r16, 1							; if equal to '1', ptr already setup.
000136 f031           breq get_msg_byte					; jump and start message load.
000137 9660           adiw YH:YL, 16						; else set ptr to dsp buff 2.
000138 e010      	 ldi r17, $00
000139 e0a6      	 ldi r26, 6
00013a 3002           cpi r16, 2							; if equal to '2', ptr now setup.
00013b f031           breq digit_load					; jump and start message load.
00013c 9660           adiw YH:YL, 16						; else set ptr to dsp buff 3.
                         
                 get_msg_byte:
00013d 9105           lpm R16, Z+						; get next byte of msg and see if '0'.        
00013e 3000           cpi R16, 0							; if equal to '0', end of message reached.
00013f f0b1           breq msg_loaded					; jump and stop message loading operation.
000140 9309           st Y+, R16							; else, store next byte of msg in buffer.
000141 cffb           rjmp get_msg_byte					; jump back and continue...
                 
                 ;__________________________________________
                 ; digital_load will only be accessed when displaying line 2, 
                 ; since the frequency to be displayed in line 2 is constantly 
                 ; changing for different waveform, the line 2 has to be adjusted 
                 ; according. 
                 ; r17, will inc until 6, to display 6 empty spaces
                 ; r4 will contain the first digit of the frequency
                 ; r3 will contain the second digit of the frequency
                 ; r2 will contain the third digit of the frequency
                 ; r1 will contian the fouth digit of the frequency
                 ;get_dis_freq subroutine will just transfer each value stored in 
                 ; r25 to y pointer
                 ;_______________________________________________	
                 digit_load:
000142 9513      	inc r17
000143 e290      	ldi r25, $20					;load empty spaces for 6 places
000144 d00f      	rcall get_dis_freq				;display 
000145 131a      	cpse r17, r26					;check if 6 places typed
000146 cffb      	rjmp digit_load					;repeat until 6 places
                 	;mov r25, r5						;load the first number in freq
                 	;rcall get_dis_freq				;display 
000147 2d94      	mov r25, r4						;load the first number in freq
000148 d00b      	rcall get_dis_freq				;display 
000149 e29e      	ldi r25, $2E
00014a d009      	rcall get_dis_freq				;load period to display inbetween numbers
00014b 2d93      	mov r25, r3						;load the second number in freq
00014c d007      	rcall get_dis_freq				;display 
00014d 2d92      	mov r25, r2						;load the third number in freq
00014e d005      	rcall get_dis_freq				;display 
00014f 2d91      	mov r25, r1						;load the fourth number in freq
000150 d003      	rcall get_dis_freq				;display 
000151 e596      	ldi r25, $56						;load the fourth number in freq
000152 d001      	rcall get_dis_freq				;display 
000153 c002      	rjmp msg_loaded					;go to the next line of the lcd
                 
                 get_dis_freq:
000154 9399      	st Y+, r25						;display the selected frquency
000155 9508      	ret		
                 
                 	
                 msg_loaded:
000156 911f      	 pop r17
000157 91af      	 pop r26
000158 9508           ret
                 ;________________________________________________________________________________________
                 
                 ;------------------------------------------------
                 ;unpacks the values store in r8 and r9 to r1- r4
                 ; r4 containe the left most number ie the thousanth
                 ;digit and r1 the right most number
                 ;------------------------------------------------
                 .def bit01 = r13
                 .def bit23 = r14
                 .def bit45 = r15
                 unpack:
000159 930f      	push r16						;store the value currently in r16
00015a d01f      	rcall bin2BCD16					;convert the values from binary to bcd
00015b 2c2d      	mov r2, bit01					;make a copy of r13 in r2
00015c 2c4e      	mov r4, bit23					;make a copy of r14 in r4
00015d 2c6f      	mov r6, bit45					;make a copy of r15 in r6
00015e e00f      	ldi r16, $0f					;use and function to
00015f 22d0      	and bit01, r16					;mask the upper nibble of r8
000160 2c1d      	mov r1, bit01					;move lower nibble to r1
000161 22e0      	and bit23, r16					;mask upper nibble of r9
000162 2c3e      	mov r3, bit23					;move lower nible to r3
000163 22f0      	and bit45, r16					;mask the upper nibble of r8
000164 2c5f      	mov r5, bit45					;move lower nibble to r1
000165 9500      	com r16							;load with f0 to mask lower nibble
000166 2220      	and r2, r16						;mask lower nibble of r8
000167 9422      	swap r2							;switch upper and lower nibble
000168 2240      	and r4, r16						;mask lower nibble of r9
000169 9442      	swap r4							;switch upper and lower nibble
                 	//and r6, r16					;mask lower nibble of r9
                 	//swap r6						;switch upper and lower nibble	
00016a e300      	ldi r16, $30
00016b 0e10      	add r1, r16
00016c 0e20      	add r2, r16
00016d 0e30      	add r3, r16
00016e 0e40      	add r4, r16
00016f 0e50      	add r5, r16						;converting the bcd's to ascii
000170 910f      	pop r16							;retrive the value previosly stored
000171 9508      	ret
                 
                 .undef bit01 
                 .undef bit23	
                 .undef bit45		
                 	
                 
                 
                 
                 ;------------------------------------------------
                 ; converts the values from bcd to ascii by adding 
                 ; 30 to it. 
                 ;------------------------------------------------
                 
                 bcd_to_ascii:
000172 930f      	push r16
000173 e300      	ldi r16, $30
000174 0f20      	add r18, r16
000175 0f30      	add r19, r16
000176 0f40      	add r20, r16
000177 0f50      	add r21, r16
000178 910f      	pop r16							;retrive the value previosly stored
000179 9508      	ret
                 
                 
                 ;_____________________________________________________________________________________
                 
                 
                 
                 
                 
                 ;***************************************************************************
                 ;*
                 ;* "bin2BCD16" - 16-bit Binary to BCD conversion
                 ;*
                 ;* This subroutine converts a 16-bit number (fbinH:fbinL) to a 5-digit
                 ;* packed BCD number represented by 3 bytes (tBCD2:tBCD1:tBCD0).
                 ;* MSD of the 5-digit number is placed in the lowermost nibble of tBCD2.
                 ;*
                 ;* Number of words	:25
                 ;* Number of cycles	:751/768 (Min/Max)
                 ;* Low registers used	:3 (tBCD0,tBCD1,tBCD2)
                 ;* High registers used  :4(fbinL,fbinH,cnt16a,tmp16a)	
                 ;* Pointers used	:Z
                 ;*
                 ;***************************************************************************
                 //.include "..\8515def.inc"
                 ;***** Subroutine Register Variables
                 
                 
                 .equ	AtBCD0	=13			;address of tBCD0
                 .equ	AtBCD2	=15			;address of tBCD1
                 
                 .def	tBCD0	=r13		;BCD value digits 1 and 0
                 .def	tBCD1	=r14		;BCD value digits 3 and 2
                 .def	tBCD2	=r15		;BCD value digit 4
                 .def	fbinL	=r16		;binary value Low byte
                 .def	fbinH	=r17		;binary value High byte
                 .def	cnt16a	=r18		;loop counter
                 .def	tmp16a	=r19		;temporary value
                 
                 ;***** Code
                 
                 bin2BCD16:
                 	//sub r18, r19
00017a 2f13      	mov fbinH, r19			;copy the values of edge counter to fbin
00017b 2f02      	mov fbinL, r18
00017c e120      	ldi	cnt16a,16			;Init loop counter	
00017d 24ff      	clr	tBCD2				;clear result (3 bytes)
00017e 24ee      	clr	tBCD1		
00017f 24dd      	clr	tBCD0		
000180 27ff      	clr	ZH					;clear ZH (not needed for AT90Sxx0x)
                 bBCDx_1:
000181 0f00      	lsl	fbinL				;shift input value
000182 1f11      	rol	fbinH				;through all bytes
000183 1cdd      	rol	tBCD0				;
000184 1cee      	rol	tBCD1
000185 1cff      	rol	tBCD2
000186 952a      	dec	cnt16a				;decrement loop counter
000187 f409      	brne bBCDx_2			;if counter not zero
000188 9508      	ret						;   return
                 
                 bBCDx_2:
000189 e1e0      	ldi	r30,AtBCD2+1		;Z points to result MSB + 1
                 bBCDx_3:	
00018a 9132      	ld	tmp16a,-Z			;get (Z) with pre-decrement
00018b 5f3d      	subi tmp16a,-$03		;add 0x03
00018c fd33      	sbrc tmp16a,3			;if bit 3 not clear
00018d 8330      	st Z,tmp16a				;store back
00018e 8130      	ld	tmp16a,Z			;get (Z)
00018f 5d30      	subi tmp16a,-$30		;add 0x30
000190 fd37      	sbrc tmp16a,7			;if bit 7 not clear
000191 8330      	st	Z,tmp16a			;store back
000192 30ed      	cpi	ZL,AtBCD0			;done all three?
000193 f7b1      	brne bBCDx_3			;loop again if not
000194 cfec      	rjmp bBCDx_1	
                 
                 .undef	tBCD0				;BCD value digits 1 and 0
                 .undef	tBCD1				;BCD value digits 3 and 2
                 .undef	tBCD2				;BCD value digit 4
                 .undef	fbinL				;binary value Low byte
                 .undef	fbinH				;binary value High byte
                 .undef	cnt16a				;loop counter
                 .undef	tmp16a				;temporary value
                 
                 ;________________________________________________________________________________	
                 
                 ;***************************************************************************
                 ;*
                 ;* "mpy16u" - 16x16 Bit Unsigned Multiplication
                 ;*
                 ;* This subroutine multiplies the two 16-bit register variables 
                 ;* mp16uH:mp16uL and mc16uH:mc16uL.
                 ;* The result is placed in m16u3:m16u2:m16u1:m16u0.
                 ;*  
                 ;* Number of words	:14 + return
                 ;* Number of cycles	:153 + return
                 ;* Low registers used	:None
                 ;* High registers used  :7 (mp16uL,mp16uH,mc16uL/m16u0,mc16uH/m16u1,m16u2,
                 ;*                          m16u3,mcnt16u)	
                 ;*
                 ;***************************************************************************
                 
                 ;***** Subroutine Register Variables
                 .def	mc16uL	=r16		;multiplicand low byte
                 .def	mc16uH	=r17		;multiplicand high byte
                 .def	mp16uL	=r18		;multiplier low byte
                 .def	mp16uH	=r19		;multiplier high byte
                 
                 .def	m16u0	=r18		;result byte 0 (LSB)
                 .def	m16u1	=r19		;result byte 1
                 .def	m16u2	=r20		;result byte 2
                 .def	m16u3	=r21		;result byte 3 (MSB)
                 .def	mcnt16u	=r22		;loop counter
                 
                 ;***** Code
                 
                 mpy16u:	
000195 2d08      	mov mc16uL, r8
000196 2d19      	mov mc16uH, r9			;copy the counts to multiplicand
000197 e322      	ldi r18, 50				;load the multiplier, to measure the
000198 2f22      	mov mp16uL, r18			;5v range
000199 2755      	clr	m16u3				;clear 2 highest bytes of result
00019a 2744      	clr	m16u2
00019b e160      	ldi	mcnt16u,16			;init loop counter
00019c 9536      	lsr	mp16uH
00019d 9527      	ror	mp16uL
                 
00019e f410      m16u_1:	brcc	noad8		;if bit 0 of multiplier set
00019f 0f40      	add	m16u2,mc16uL		;add multiplicand Low to byte 2 of res
0001a0 1f51      	adc	m16u3,mc16uH		;add multiplicand high to byte 3 of res
                 
0001a1 9557      noad8:	ror	m16u3			;shift right result byte 3
0001a2 9547      	ror	m16u2				;rotate right result byte 2
0001a3 9537      	ror	m16u1				;rotate result byte 1 and multiplier High
0001a4 9527      	ror	m16u0				;rotate result byte 0 and multiplier Low
0001a5 956a      	dec	mcnt16u				;decrement loop counter
0001a6 f7b9      	brne	m16u_1			;if not done, loop more
                 	
                 
                 .undef	mc16uL				;multiplicand low byte
                 .undef	mc16uH				;multiplicand high byte
                 .undef	mp16uL				;multiplier low byte
                 .undef	mp16uH				;multiplier high byte
                 .undef	m16u0				;result byte 0 (LSB)
                 .undef	m16u1				;result byte 1
                 .undef	m16u2				;result byte 2
                 .undef	m16u3				;result byte 3 (MSB)
                 .undef	mcnt16u				;loop counter
                 
0001a7 9508      	ret
                 ;______________________________________________________________________
                 
                 ;***************************************************************************
                 ;*
                 ;* "div32u" - 32/32 Bit Unsigned Division
                 ;*
                 ;* Ken Short
                 ;*
                 ;* This subroutine divides the two 32-bit numbers 
                 ;* "dd32u3:dd32u2:dd32u1:dd32u0" (dividend) and "dv32u3:dv32u2:dv32u3:dv32u2"
                 ;* (divisor). 
                 ;* The result is placed in "dres32u3:dres32u2:dres32u3:dres32u2" and the
                 ;* remainder in "drem32u3:drem32u2:drem32u3:drem32u2".
                 ;*  
                 ;* Number of words	:
                 ;* Number of cycles	:655/751 (Min/Max) ATmega16
                 ;* #Low registers used	:2 (drem16uL,drem16uH)
                 ;* #High registers used  :5 (dres16uL/dd16uL,dres16uH/dd16uH,dv16uL,dv16uH,
                 ;*			    dcnt16u)
                 ;* A $0000 divisor returns $FFFF
                 ;*
                 ;***************************************************************************
                 
                 ;***** Subroutine Register Variables
                 
                 .def	drem32u0=r12    ;remainder
                 .def	drem32u1=r13
                 .def	drem32u2=r14
                 .def	drem32u3=r15
                 
                 .def	dres32u0=r18    ;result (quotient)
                 .def	dres32u1=r19
                 .def	dres32u2=r20
                 .def	dres32u3=r21
                 .undef	dres32u0	    ;result (quotient)
                 .undef	dres32u1	
                 .undef	dres32u2	
                 .undef	dres32u3
                 .def	dd32u0	=r18    ;dividend
                 .def	dd32u1	=r19
                 .def	dd32u2	=r20
                 .def	dd32u3	=r21
                 
                 .def	dv32u0	=r22    ;divisor
                 .def	dv32u1	=r23
                 .def	dv32u2	=r24
                 .def	dv32u3	=r25
                 
                 .def	dcnt32u	=r17
                 
                 ;***** Code
                 
                 div32u:
                 
0001a8 e06a      	ldi r22, 10
0001a9 2f66      	mov dv32u0, r22			; divide by 10
                 
0001aa 24cc      	clr	drem32u0			;clear remainder Low byte
0001ab 24dd          clr drem32u1
0001ac 24ee          clr drem32u2
0001ad 18ff      	sub	drem32u3,drem32u3	;clear remainder High byte and carry
0001ae e211      	ldi	dcnt32u,33			;init loop counter
                 d32u_1:
0001af 1f22      	rol	dd32u0				;shift left dividend
0001b0 1f33      	rol	dd32u1
0001b1 1f44      	rol	dd32u2    
0001b2 1f55      	rol	dd32u3
0001b3 951a      	dec	dcnt32u				;decrement counter
0001b4 f409      	brne d32u_2				;if done
0001b5 9508      	ret						;    return
                 d32u_2:
0001b6 1ccc      	rol	drem32u0			;shift dividend into remainder
0001b7 1cdd          rol	drem32u1
0001b8 1cee          rol	drem32u2
0001b9 1cff      	rol	drem32u3
                 
0001ba 1ac6      	sub	drem32u0,dv32u0		;remainder = remainder - divisor
0001bb 0ad7          sbc	drem32u1,dv32u1
0001bc 0ae8          sbc	drem32u2,dv32u2
0001bd 0af9      	sbc	drem32u3,dv32u3		;
0001be f430      	brcc	d32u_3			;   branch if reult is pos or zero
                 
0001bf 0ec6      	add	drem32u0,dv32u0		;    if result negative restore remainder
0001c0 1ed7      	adc	drem32u1,dv32u1
0001c1 1ee8      	adc	drem32u2,dv32u2
0001c2 1ef9      	adc	drem32u3,dv32u3
0001c3 9488      	clc						;    clear carry to be shifted into result
0001c4 cfea      	rjmp	d32u_1			;else
0001c5 9408      d32u_3:	sec					;    set carry to be shifted into result
0001c6 cfe8      	rjmp	d32u_1
                 	/*
                 .undef	drem32u0		    ;remainder
                 .undef	drem32u1	
                 .undef	drem32u2	
                 .undef	drem32u3	
                 	
                 .undef	dd32u0				;dividend
                 .undef	dd32u1		
                 .undef	dd32u2		
                 .undef	dd32u3		
                 .undef	dv32u0				;divisor
                 .undef	dv32u1			
                 .undef	dv32u2		
                 .undef	dv32u3		
                 .undef	dcnt32u	
                 
                 */
                 ;------------DELAY 10 MS--------------------------
                 ;This subroutine is placed here, if it was required during 
                 ; the lab. Its not called anywhere in the code. 
                 ;delays for 10ms 
                 ;r20 set to 100
                 ;r21 set to 33
                 ; combined delay will yield 9999 clock cycles
                 ;-------------------------------------------------
                 delay:
0001c7 e644      	ldi r20,100
                 	outer:
0001c8 e251      		ldi r21, 33
                 		inner:
0001c9 955a      			dec r21
0001ca f7f1      			brne inner
0001cb 954a      			dec r20
0001cc f7d9      			brne outer
0001cd 9508      	ret


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega16" register use summary:
r0 :   0 r1 :   3 r2 :   5 r3 :   3 r4 :   5 r5 :   2 r6 :   1 r7 :   0 
r8 :   2 r9 :   2 r10:   0 r11:   0 r12:   4 r13:   9 r14:   9 r15:  10 
r16: 106 r17:  19 r18:  10 r19:  13 r20:  15 r21:   7 r22:   9 r23:   4 
r24:   6 r25:  12 r26:   6 r27:   5 r28:   3 r29:   3 r30:  15 r31:  14 
x  :   0 y  :   2 z  :  10 
Registers used: 30 out of 35 (85.7%)

"ATmega16" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   4 add   :  11 adiw  :   2 and   :   6 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   0 break :   0 breq  :   4 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  13 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   3 cbr   :   0 
clc   :   1 clh   :   0 cli   :   0 cln   :   0 clr   :   9 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   4 cp    :   0 cpc   :   0 
cpi   :   4 cpse  :   1 dec   :  12 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  15 inc   :   1 jmp   :   2 
ld    :   5 ldd   :   0 ldi   :  77 lds   :   0 lpm   :   2 lsl   :   1 
lsr   :   1 mov   :  16 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :   2 or    :   0 ori   :   0 out   :  18 pop   :  13 
push  :  13 rcall :  66 ret   :  20 reti  :   1 rjmp  :  18 rol   :  12 
ror   :   5 sbc   :   3 sbci  :   0 sbi   :   6 sbic  :   0 sbis  :   1 
sbiw  :   0 sbr   :   0 sbrc  :   4 sbrs  :   5 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   5 std   :   0 sts   :   0 
sub   :   2 subi  :   2 swap  :   2 tst   :   0 wdr   :   0 
Instructions used: 49 out of 113 (43.4%)

"ATmega16" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00039c    810    114    924   16384   5.6%
[.dseg] 0x000060 0x000090      0     48     48    1024   4.7%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 2 warnings
